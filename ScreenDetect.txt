# -*- coding: utf-8 -*-
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import (QFileDialog, QLabel, QGraphicsView, QGraphicsScene,
                             QMessageBox, QVBoxLayout, QWidget, QTextEdit,
                             QSpinBox, QDoubleSpinBox, QComboBox, QPushButton,
                             QSizePolicy, QGroupBox)
from PyQt5.QtCore import Qt, QThread, pyqtSignal, QTimer
import cv2
import numpy as np
import sys
import os
import time
import json
from queue import Queue, Empty
import traceback
import serial
import serial.tools.list_ports

# --- Constants ---
REF_NORM = "Norm"
REF_SHUTDOWN = "Shutdown" # Gi·ªØ nguy√™n gi√° tr·ªã constant
REF_FAIL = "Fail"
DEFAULT_SSIM_THRESHOLD = 0.90
DEFAULT_ERROR_COOLDOWN = 15
DEFAULT_RUNTIME_MINUTES = 0
DEFAULT_RECORD_ON_ERROR = False
DEFAULT_SERIAL_ENABLED = False
DEFAULT_BAUD_RATE = 9600
CONFIG_FILE_NAME = "image_checker_config.json"
LOG_FILE_NAME = "activity_log.txt"
VIDEO_SUBFOLDER = "error_videos"
COMMON_BAUD_RATES = [9600, 19200, 38400, 57600, 115200]

# --- H√†m t√≠nh SSIM b·∫±ng OpenCV ---
def ssim_opencv(img1, img2, K1=0.01, K2=0.03, win_size=7, data_range=255.0):
    if img1 is None or img2 is None: return None
    if len(img1.shape) > 2: img1 = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)
    if len(img2.shape) > 2: img2 = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)
    # T·ª± ƒë·ªông resize n·∫øu k√≠ch th∆∞·ªõc kh√°c nhau (·∫£nh 2 v·ªÅ k√≠ch th∆∞·ªõc ·∫£nh 1)
    if img1.shape != img2.shape:
        try:
            h1, w1 = img1.shape[:2]
            h2, w2 = img2.shape[:2]
            interpolation = cv2.INTER_AREA if (w2 > w1 or h2 > h1) else cv2.INTER_LINEAR
            img2 = cv2.resize(img2, (w1, h1), interpolation=interpolation)
            # print(f"SSIM Resized img2 from {w2}x{h2} to {w1}x{h1}") # Debug log
        except Exception as resize_err:
            print(f"Error resizing image for SSIM: {resize_err}") # N√™n d√πng logging thay print
            return None
    # ƒê√£ resize (n·∫øu c·∫ßn), ti·∫øp t·ª•c t√≠nh to√°n
    h, w = img1.shape; win_size = min(win_size, h, w)
    if win_size % 2 == 0: win_size -= 1
    if win_size < 3: return None # K√≠ch th∆∞·ªõc c·ª≠a s·ªï qu√° nh·ªè
    if img1.dtype != np.float64: img1 = img1.astype(np.float64)
    if img2.dtype != np.float64: img2 = img2.astype(np.float64)
    C1=(K1*data_range)**2; C2=(K2*data_range)**2; sigma=1.5
    mu1=cv2.GaussianBlur(img1,(win_size,win_size),sigma); mu2=cv2.GaussianBlur(img2,(win_size,win_size),sigma)
    mu1_sq=mu1*mu1; mu2_sq=mu2*mu2; mu1_mu2=mu1*mu2
    sigma1_sq=cv2.GaussianBlur(img1*img1,(win_size,win_size),sigma)-mu1_sq
    sigma2_sq=cv2.GaussianBlur(img2*img2,(win_size,win_size),sigma)-mu2_sq
    sigma12=cv2.GaussianBlur(img1*img2,(win_size,win_size),sigma)-mu1_mu2
    num=(2*mu1_mu2+C1)*(2*sigma12+C2); den=(mu1_sq+mu2_sq+C1)*(sigma1_sq+sigma2_sq+C2)
    eps=1e-8; ssim_map=num/(den+eps); ssim_map=np.clip(ssim_map,0,1)
    mssim=np.mean(ssim_map)
    if not np.isfinite(mssim): return None # X·ª≠ l√Ω NaN/inf
    return mssim

# --- Worker Thread ---
class ProcessingWorker(QThread):
    log_signal = pyqtSignal(str); status_signal = pyqtSignal(str, str)
    save_error_signal = pyqtSignal(np.ndarray, str); ssim_signal = pyqtSignal(float)
    error_detected_signal = pyqtSignal(); serial_command_signal = pyqtSignal(str)

    def __init__(self, frame_queue, ref_images_provider, config_provider, compare_func):
        super().__init__(); self.frame_queue=frame_queue; self.get_ref_images=lambda: ref_images_provider().copy(); self.get_config=config_provider; self.compare_images=compare_func; self.running=False; self.last_error_time=0; self.last_emitted_serial_state=None

    def run(self):
        self.running=True; self.log_signal.emit("‚öôÔ∏è Worker started."); last_status_normal_log_time=0; error_signaled_this_session=False; self.last_emitted_serial_state=None
        while self.running:
            try:
                frame=self.frame_queue.get(timeout=0.5)
            except Empty:
                if not self.running: break
                continue
            except Exception as e: # B·∫Øt l·ªói khi l·∫•y frame t·ª´ queue
                self.log_signal.emit(f"‚ùå Error getting frame from queue: {e}")
                continue # B·ªè qua frame n√†y v√† ti·∫øp t·ª•c v√≤ng l·∫∑p

            if not self.running: break # Ki·ªÉm tra l·∫°i sau khi l·∫•y frame

            try:
                # L·∫•y config v√† ·∫£nh tham chi·∫øu M·ªöI NH·∫§T m·ªói v√≤ng l·∫∑p
                cfg=self.get_config()
                ssim_th=cfg.get('ssim_threshold',DEFAULT_SSIM_THRESHOLD)
                err_cd=cfg.get('error_cooldown',DEFAULT_ERROR_COOLDOWN)
                err_f=cfg.get('error_folder')
                refs=self.get_ref_images()
                n_img,s_img,f_img = refs.get(REF_NORM), refs.get(REF_SHUTDOWN), refs.get(REF_FAIL)

                # --- Ki·ªÉm tra ·∫£nh Norm ---
                if not isinstance(n_img,np.ndarray) or n_img.size == 0:
                    ct=time.time();
                    if not hasattr(self,'lnwt') or ct-getattr(self,'lnwt',0)>60: # Log m·ªói 60s
                        self.log_signal.emit("‚ö†Ô∏è ·∫¢nh Norm kh√¥ng h·ª£p l·ªá ho·∫∑c ch∆∞a ƒë∆∞·ª£c t·∫£i. Kh√¥ng th·ªÉ so s√°nh."); setattr(self,'lnwt',ct)
                    self.ssim_signal.emit(-1.0) # G·ª≠i t√≠n hi·ªáu kh√¥ng c√≥ SSIM
                    time.sleep(0.1); continue # Ch·ªù v√† b·ªè qua v√≤ng l·∫∑p n√†y
                else: # ·∫¢nh Norm OK, x√≥a timer log l·ªói n·∫øu c√≥
                    if hasattr(self,'lnwt'): delattr(self,'lnwt')

                # --- So s√°nh v·ªõi ·∫£nh Norm ---
                is_match_n, score_n = self.compare_images(frame, n_img, ssim_th)
                self.ssim_signal.emit(score_n if score_n is not None else -1.0) # G·ª≠i ƒëi·ªÉm SSIM (ho·∫∑c -1 n·∫øu l·ªói)

                if score_n is None: # L·ªói khi so s√°nh v·ªõi Norm
                    ct=time.time();
                    if not hasattr(self,'lcflt') or ct-getattr(self,'lcflt',0)>10: # Log m·ªói 10s
                        self.log_signal.emit("‚ö†Ô∏è L·ªói khi so s√°nh frame v·ªõi ·∫£nh Norm."); setattr(self,'lcflt',ct)
                    time.sleep(0.1); continue # Ch·ªù v√† b·ªè qua
                if hasattr(self,'lcflt'): delattr(self,'lcflt') # So s√°nh OK, x√≥a timer log l·ªói

                ser_state=None # Tr·∫°ng th√°i serial s·∫Ω g·ª≠i (Norm, Shutdown, Fail)

                # --- Tr∆∞·ªùng h·ª£p kh·ªõp Norm ---
                if is_match_n:
                    ct=time.time();
                    if ct-last_status_normal_log_time>5: # C·∫≠p nh·∫≠t status "Normal" m·ªói 5s
                        self.status_signal.emit("Normal","lightgreen"); last_status_normal_log_time=ct
                    ser_state=REF_NORM;
                    # Ch·ªâ g·ª≠i l·ªánh serial n·∫øu tr·∫°ng th√°i thay ƒë·ªïi
                    if self.last_emitted_serial_state != ser_state:
                        self.serial_command_signal.emit(ser_state)
                        self.last_emitted_serial_state = ser_state
                    time.sleep(0.05) # Gi·∫£m t·∫£i CPU m·ªôt ch√∫t khi normal
                    continue # ·∫¢nh kh·ªõp Norm, quay l·∫°i ƒë·∫ßu v√≤ng l·∫∑p ch√≠nh

                # --- Tr∆∞·ªùng h·ª£p KH√îNG kh·ªõp Norm ---
                last_status_normal_log_time=0 # Reset timer log normal
                msg,color,save_img,err_sub="Unknown Mismatch!","orange",True,"unknown" # Gi√° tr·ªã m·∫∑c ƒë·ªãnh
                log_m=f"‚ö†Ô∏è Kh√¥ng kh·ªõp Norm (SSIM: {score_n:.4f})."
                rec_err=True # M·∫∑c ƒë·ªãnh l√† l·ªói c·∫ßn ghi h√¨nh/l∆∞u ·∫£nh
                ser_state=REF_FAIL # M·∫∑c ƒë·ªãnh g·ª≠i Fail n·∫øu kh√¥ng kh·ªõp c√°c tr·∫°ng th√°i kh√°c

                # --- Ki·ªÉm tra kh·ªõp Shutdown (ch·ªâ n·∫øu ·∫£nh Shutdown t·ªìn t·∫°i) ---
                if isinstance(s_img, np.ndarray) and s_img.size > 0:
                    is_match_s, score_s = self.compare_images(frame, s_img, ssim_th)
                    if score_s is not None and is_match_s:
                        msg,color,err_sub="Shutdown","lightblue","shutdown"
                        log_m=f"‚ÑπÔ∏è Tr·∫°ng th√°i Shutdown (SSIM vs Shutdown: {score_s:.4f})."
                        rec_err=False # Shutdown th∆∞·ªùng kh√¥ng ph·∫£i l·ªói c·∫ßn ghi l·∫°i
                        ser_state=REF_SHUTDOWN
                        self.log_signal.emit(log_m) # Log tr·∫°ng th√°i Shutdown
                        self.status_signal.emit(msg,color) # C·∫≠p nh·∫≠t status UI

                # --- Ki·ªÉm tra kh·ªõp Fail (ch·ªâ n·∫øu ·∫£nh Fail t·ªìn t·∫°i v√† CH∆ØA kh·ªõp Shutdown) ---
                if ser_state != REF_SHUTDOWN and isinstance(f_img, np.ndarray) and f_img.size > 0:
                     is_match_f, score_f = self.compare_images(frame, f_img, ssim_th)
                     if score_f is not None and is_match_f:
                         msg,color,err_sub="FAIL!","red","fail"
                         log_m=f"‚ùå Tr·∫°ng th√°i FAIL (SSIM vs Fail: {score_f:.4f})."
                         rec_err=True # Fail l√† l·ªói c·∫ßn ghi l·∫°i
                         ser_state=REF_FAIL
                         self.log_signal.emit(log_m) # Log tr·∫°ng th√°i Fail
                         self.status_signal.emit(msg,color) # C·∫≠p nh·∫≠t status UI

                # N·∫øu v·∫´n l√† unknown (kh√¥ng kh·ªõp Norm, Shutdown, Fail), log v√† c·∫≠p nh·∫≠t status
                if err_sub=="unknown":
                    self.log_signal.emit(log_m) # Log mismatch ban ƒë·∫ßu
                    self.status_signal.emit(msg,color)

                # --- X·ª≠ l√Ω sau khi x√°c ƒë·ªãnh tr·∫°ng th√°i ---
                # G·ª≠i t√≠n hi·ªáu l·ªói ƒë·ªÉ b·∫Øt ƒë·∫ßu ghi video n·∫øu c·∫ßn (ch·ªâ 1 l·∫ßn/phi√™n x·ª≠ l√Ω)
                if rec_err and not error_signaled_this_session:
                    self.error_detected_signal.emit()
                    error_signaled_this_session = True

                # G·ª≠i l·ªánh Serial n·∫øu tr·∫°ng th√°i thay ƒë·ªïi so v·ªõi l·∫ßn g·ª≠i tr∆∞·ªõc
                if ser_state and self.last_emitted_serial_state != ser_state:
                     self.serial_command_signal.emit(ser_state)
                     self.last_emitted_serial_state = ser_state

                # L∆∞u ·∫£nh l·ªói n·∫øu c·∫ßn, c√≥ th∆∞ m·ª•c l·ªói v√† ƒë√£ h·∫øt cooldown
                ct=time.time();
                if save_img and err_f and (ct-self.last_error_time > err_cd):
                    try:
                        save_folder=os.path.join(err_f, err_sub) # Th∆∞ m·ª•c con theo lo·∫°i l·ªói
                        os.makedirs(save_folder, exist_ok=True) # T·∫°o n·∫øu ch∆∞a c√≥
                        timestamp=time.strftime('%Y%m%d_%H%M%S') + f"_{int((ct-int(ct))*1000):03d}" # Th√™m ms
                        filename=f"{err_sub}_{timestamp}.png"
                        filepath=os.path.join(save_folder, filename)
                        # G·ª≠i t√≠n hi·ªáu ƒë·ªÉ lu·ªìng ch√≠nh th·ª±c hi·ªán l∆∞u file I/O
                        self.save_error_signal.emit(frame.copy(), filepath)
                        self.last_error_time = ct # Reset cooldown timer
                    except Exception as e:
                        self.log_signal.emit(f"‚ùå L·ªói khi chu·∫©n b·ªã l∆∞u ·∫£nh l·ªói: {e}")
                elif not err_f and save_img: # Log c·∫£nh b√°o n·∫øu c·∫ßn l∆∞u nh∆∞ng ch∆∞a c√≥ folder
                    ct2=time.time()
                    if not hasattr(self,'lsfw') or ct2-getattr(self,'lsfw',0)>60: # Log m·ªói 60s
                        self.log_signal.emit("‚ö†Ô∏è Ch∆∞a c·∫•u h√¨nh th∆∞ m·ª•c l·ªói ƒë·ªÉ l∆∞u ·∫£nh.")
                        setattr(self,'lsfw',ct2)
                # else: # Kh√¥ng c·∫ßn l∆∞u ho·∫∑c ƒëang cooldown
                #     pass

                time.sleep(0.1) # Gi·∫£m t·∫£i CPU m·ªôt ch√∫t khi c√≥ mismatch/l·ªói

            except Exception as e: # B·∫Øt l·ªói chung trong logic so s√°nh
                self.log_signal.emit(f"‚ùå L·ªói nghi√™m tr·ªçng trong worker logic: {e}")
                self.log_signal.emit(traceback.format_exc())
                time.sleep(0.5) # Ch·ªù m·ªôt ch√∫t n·∫øu c√≥ l·ªói nghi√™m tr·ªçng

        # --- K·∫øt th√∫c v√≤ng l·∫∑p while self.running ---
        self.log_signal.emit("‚öôÔ∏è Worker finished.")
        # Reset tr·∫°ng th√°i khi worker d·ª´ng
        self.last_emitted_serial_state = None
        error_signaled_this_session = False # Reset c·ªù ƒë·ªÉ l·∫ßn ch·∫°y sau c√≥ th·ªÉ g·ª≠i l·∫°i


    def stop(self):
        self.running=False
        self.log_signal.emit("‚öôÔ∏è ƒêang y√™u c·∫ßu d·ª´ng worker...") # Log y√™u c·∫ßu d·ª´ng

# --- Main Application Window ---
class ImageCheckerApp(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        # --- Kh·ªüi t·∫°o State Variables ---
        self.cap=None; self.webcam_fps=15.0; self.frame_timer=QTimer(self); self.ref_images={k:None for k in[REF_NORM,REF_SHUTDOWN,REF_FAIL]}; self.webcam_roi=None; self.processing=False; self.error_folder=None; self.log_file_path=None; self.pixmap_item=None; self.runtime_timer=QTimer(self); self._current_runtime_minutes=DEFAULT_RUNTIME_MINUTES; self._current_ssim_threshold=DEFAULT_SSIM_THRESHOLD; self._current_error_cooldown=DEFAULT_ERROR_COOLDOWN; self._record_on_error_enabled=DEFAULT_RECORD_ON_ERROR; self.video_writer=None; self.current_video_path=None; self.error_occurred_during_recording=False; self.serial_port=None; self.serial_port_name=None; self.serial_baud_rate=DEFAULT_BAUD_RATE; self.serial_enabled=DEFAULT_SERIAL_ENABLED

        # --- Kh·ªüi t·∫°o Config Dictionary ---
        self.config={'ssim_threshold':self._current_ssim_threshold,'error_cooldown':self._current_error_cooldown,'runtime_duration_minutes':self._current_runtime_minutes,'record_on_error':self._record_on_error_enabled,'error_folder':None,'ref_paths':{k:None for k in[REF_NORM,REF_SHUTDOWN,REF_FAIL]},'webcam_roi':None,'serial_port':self.serial_port_name,'serial_baud':self.serial_baud_rate,'serial_enabled':self.serial_enabled,}

        # --- C·∫•u h√¨nh Timers v√† Queue ---
        self.frame_timer.timeout.connect(self.update_frame)
        self.runtime_timer.setSingleShot(True)
        self.runtime_timer.timeout.connect(self._runtime_timer_timeout)
        self.frame_queue=Queue(maxsize=10) # Gi·ªõi h·∫°n queue ƒë·ªÉ tr√°nh d√πng qu√° nhi·ªÅu RAM

        # --- Kh·ªüi t·∫°o Worker Thread ---
        self.processing_worker=ProcessingWorker(
            self.frame_queue,
            lambda:self.ref_images, # Cung c·∫•p ·∫£nh tham chi·∫øu
            lambda:self.get_current_config_for_worker(), # Cung c·∫•p config c·∫ßn thi·∫øt
            self.compare_images # Cung c·∫•p h√†m so s√°nh
        )
        # K·∫øt n·ªëi signals t·ª´ worker t·ªõi slots c·ªßa Main thread
        self.processing_worker.log_signal.connect(self.log_activity)
        self.processing_worker.status_signal.connect(self.update_status_label)
        self.processing_worker.save_error_signal.connect(self.save_error_image_from_thread)
        self.processing_worker.ssim_signal.connect(self.update_ssim_display)
        self.processing_worker.error_detected_signal.connect(self._mark_error_occurred)
        self.processing_worker.serial_command_signal.connect(self._send_serial_command)

        # --- Kh·ªüi t·∫°o Giao di·ªán v√† T·∫£i c·∫•u h√¨nh ---
        self.init_ui() # Ph·∫£i g·ªçi tr∆∞·ªõc load_config ƒë·ªÉ c√°c widget t·ªìn t·∫°i
        self.load_config() # T·∫£i c·∫•u h√¨nh t·ª´ file (n·∫øu c√≥)
        self._refresh_com_ports() # L√†m m·ªõi danh s√°ch c·ªïng COM ban ƒë·∫ßu
        self.log_activity("·ª®ng d·ª•ng kh·ªüi ƒë·ªông.")
        self.update_all_ui_elements() # C·∫≠p nh·∫≠t UI v·ªõi gi√° tr·ªã ƒë√£ t·∫£i/m·∫∑c ƒë·ªãnh

    def get_current_config_for_worker(self):
        # Ch·ªâ g·ª≠i nh·ªØng config c·∫ßn thi·∫øt cho worker ƒë·ªÉ gi·∫£m overhead
        return {
            'ssim_threshold': self._current_ssim_threshold,
            'error_cooldown': self._current_error_cooldown,
            'error_folder': self.error_folder # Worker c·∫ßn bi·∫øt th∆∞ m·ª•c ƒë·ªÉ l∆∞u ·∫£nh
            }

    # --- Slots C·∫≠p nh·∫≠t Config/State t·ª´ UI ---
    @QtCore.pyqtSlot(float)
    def _update_threshold_config(self,value):
        if self._current_ssim_threshold!=value:
            self._current_ssim_threshold=value; self.log_activity(f"‚öôÔ∏è Ng∆∞·ª°ng SSIM ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh: {value:.3f}"); self.config['ssim_threshold']=value
            # Kh√¥ng c·∫ßn save_config() ngay, s·∫Ω l∆∞u khi b·∫Øt ƒë·∫ßu x·ª≠ l√Ω ho·∫∑c ƒë√≥ng app

    @QtCore.pyqtSlot(int)
    def _update_cooldown_config(self,value):
        if self._current_error_cooldown!=value:
            self._current_error_cooldown=value; self.log_activity(f"‚öôÔ∏è Cooldown l∆∞u ·∫£nh l·ªói ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh: {value} gi√¢y"); self.config['error_cooldown']=value

    @QtCore.pyqtSlot(int)
    def _update_runtime_config(self,value):
        if self._current_runtime_minutes!=value:
            self._current_runtime_minutes=value; log_msg=f"‚öôÔ∏è Th·ªùi gian ch·∫°y t·ªëi ƒëa ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh: {'V√¥ h·∫°n' if value==0 else f'{value} ph√∫t'}"; self.log_activity(log_msg); self.config['runtime_duration_minutes']=value

    @QtCore.pyqtSlot()
    def _toggle_record_on_error(self):
        # Kh√¥ng cho ph√©p thay ƒë·ªïi khi ƒëang x·ª≠ l√Ω
        if self.processing:
            QMessageBox.warning(self,"ƒêang X·ª≠ L√Ω","Kh√¥ng th·ªÉ thay ƒë·ªïi c√†i ƒë·∫∑t ghi video khi ƒëang x·ª≠ l√Ω.")
            return
        self._record_on_error_enabled = not self._record_on_error_enabled
        self.config['record_on_error'] = self._record_on_error_enabled
        self.update_record_button_style() # C·∫≠p nh·∫≠t style n√∫t ngay
        log_msg = f"‚öôÔ∏è Ghi video khi c√≥ l·ªói: {'B·∫≠t' if self._record_on_error_enabled else 'T·∫Øt'}"
        self.log_activity(log_msg)
        self.save_config() # L∆∞u thay ƒë·ªïi n√†y ngay l·∫≠p t·ª©c

    @QtCore.pyqtSlot(str)
    def _update_serial_port_config(self,port_name):
        # Ch·ªâ c·∫≠p nh·∫≠t n·∫øu t√™n c·ªïng th·ª±c s·ª± thay ƒë·ªïi v√† kh√¥ng ph·∫£i placeholder
        new_port = port_name if port_name and "Kh√¥ng t√¨m th·∫•y" not in port_name else None
        if self.serial_port_name != new_port:
             self.serial_port_name = new_port
             self.config['serial_port']=self.serial_port_name;
             self.log_activity(f"‚öôÔ∏è C·ªïng COM ƒë∆∞·ª£c ch·ªçn: {self.serial_port_name or 'Ch∆∞a ch·ªçn'}");
             # C·∫£nh b√°o n·∫øu ƒëang k·∫øt n·ªëi
             if self.serial_enabled:
                 self.log_activity("‚ö†Ô∏è Thay ƒë·ªïi c·ªïng COM y√™u c·∫ßu Ng·∫Øt k·∫øt n·ªëi v√† K·∫øt n·ªëi l·∫°i.")

    @QtCore.pyqtSlot(str)
    def _update_serial_baud_config(self,baud_str):
        try:
            bd=int(baud_str);
            # Ch·ªâ c·∫≠p nh·∫≠t n·∫øu baud rate thay ƒë·ªïi
            if self.serial_baud_rate != bd:
                if bd in COMMON_BAUD_RATES: # Ch·ªâ ch·∫•p nh·∫≠n baud rate h·ª£p l·ªá
                    self.serial_baud_rate=bd; self.config['serial_baud']=bd;
                    self.log_activity(f"‚öôÔ∏è Baud rate ƒë∆∞·ª£c ch·ªçn: {bd}");
                    # C·∫£nh b√°o n·∫øu ƒëang k·∫øt n·ªëi
                    if self.serial_enabled:
                         self.log_activity("‚ö†Ô∏è Thay ƒë·ªïi Baud rate y√™u c·∫ßu Ng·∫Øt k·∫øt n·ªëi v√† K·∫øt n·ªëi l·∫°i.")
                else:
                     self.log_activity(f"‚ö†Ô∏è Baud rate kh√¥ng h·ª£p l·ªá: {bd}. S·ª≠ d·ª•ng gi√° tr·ªã c≈©: {self.serial_baud_rate}")
                     # ƒê·∫∑t l·∫°i ComboBox v·ªÅ gi√° tr·ªã c≈©
                     idx=self.baudRateComboBox.findText(str(self.serial_baud_rate));
                     if idx>=0:
                         self.baudRateComboBox.blockSignals(True)
                         self.baudRateComboBox.setCurrentIndex(idx)
                         self.baudRateComboBox.blockSignals(False)

        except ValueError:
            self.log_activity(f"‚ö†Ô∏è Gi√° tr·ªã Baud rate nh·∫≠p v√†o kh√¥ng ph·∫£i s·ªë: {baud_str}");
            # ƒê·∫∑t l·∫°i ComboBox v·ªÅ gi√° tr·ªã c≈©
            idx=self.baudRateComboBox.findText(str(self.serial_baud_rate));
            if idx>=0:
                self.baudRateComboBox.blockSignals(True)
                self.baudRateComboBox.setCurrentIndex(idx)
                self.baudRateComboBox.blockSignals(False)

    # --- init_ui ---
    def init_ui(self):
        self.setWindowTitle("Image Checker v2.8 (Fixed Syntax)"); self.setGeometry(100,100,1350,760);
        central_widget=QWidget(self); self.setCentralWidget(central_widget)

        # --- Graphics View (Hi·ªÉn th·ªã Webcam) ---
        self.scene=QGraphicsScene(self)
        self.graphicsView=QGraphicsView(self.scene, central_widget)
        self.graphicsView.setGeometry(10,10,640,360)
        self.graphicsView.setStyleSheet("border: 1px solid black;")
        self.graphicsView.setBackgroundBrush(QtGui.QBrush(Qt.darkGray)) # N·ªÅn x√°m khi ch∆∞a c√≥ video

        # --- Buttons (C·ªôt tr√°i) ---
        bw,bh,vs,bx,yp = 201, 31, 40, 20, 380 # Button width, height, vertical spacing, x-pos, y-start
        # Webcam Controls
        self.ONCam=self.create_button("üì∑ B·∫≠t Webcam"); self.ONCam.setGeometry(bx,yp,bw,bh); self.ONCam.clicked.connect(self.start_webcam)
        self.OFFCam=self.create_button("üö´ T·∫Øt Webcam"); self.OFFCam.setGeometry(bx+bw+10,yp,bw,bh); self.OFFCam.clicked.connect(self.stop_webcam); self.OFFCam.setEnabled(False); yp+=vs
        # Load Reference Image Buttons
        self.SettingButton_Norm=self.create_button("üìÇ ·∫¢nh Norm"); self.SettingButton_Norm.setGeometry(bx,yp,bw,bh); self.SettingButton_Norm.clicked.connect(lambda: self.load_reference_image(REF_NORM))
        self.SettingButton_Shutdown=self.create_button("üìÇ ·∫¢nh Shutdown"); self.SettingButton_Shutdown.setGeometry(bx+bw+10,yp,bw,bh); self.SettingButton_Shutdown.clicked.connect(lambda: self.load_reference_image(REF_SHUTDOWN))
        self.SettingButton_Fail=self.create_button("üìÇ ·∫¢nh Fail"); self.SettingButton_Fail.setGeometry(bx+2*(bw+10),yp,bw,bh); self.SettingButton_Fail.clicked.connect(lambda: self.load_reference_image(REF_FAIL)); yp+=vs
        # Capture Reference Image Buttons
        self.CaptureButton_Norm=self.create_button("üì∏ Ch·ª•p Norm"); self.CaptureButton_Norm.setGeometry(bx,yp,bw,bh); self.CaptureButton_Norm.clicked.connect(lambda: self.capture_reference_from_webcam(REF_NORM)); self.CaptureButton_Norm.setEnabled(False)
        self.CaptureButton_Shut=self.create_button("üì∏ Ch·ª•p Shutdown"); self.CaptureButton_Shut.setGeometry(bx+bw+10,yp,bw,bh); self.CaptureButton_Shut.clicked.connect(lambda: self.capture_reference_from_webcam(REF_SHUTDOWN)); self.CaptureButton_Shut.setEnabled(False)
        self.CaptureButton_Fail=self.create_button("üì∏ Ch·ª•p Fail"); self.CaptureButton_Fail.setGeometry(bx+2*(bw+10),yp,bw,bh); self.CaptureButton_Fail.clicked.connect(lambda: self.capture_reference_from_webcam(REF_FAIL)); self.CaptureButton_Fail.setEnabled(False); yp+=vs
        # ROI and Processing Buttons
        self.SettingButton_ROI_Webcam=self.create_button("‚úÇÔ∏è Ch·ªçn ROI"); self.SettingButton_ROI_Webcam.setGeometry(bx,yp,bw,bh); self.SettingButton_ROI_Webcam.clicked.connect(self.select_webcam_roi); self.SettingButton_ROI_Webcam.setEnabled(False);
        self.SaveButton=self.create_button("üìÅ Th∆∞ m·ª•c l·ªói"); self.SaveButton.setGeometry(bx+bw+10,yp,bw,bh); self.SaveButton.clicked.connect(self.select_error_folder) # ƒê·ªïi v·ªã tr√≠
        self.ToggleProcessingButton=self.create_button("‚ñ∂Ô∏è B·∫Øt ƒë·∫ßu"); self.ToggleProcessingButton.setGeometry(bx+2*(bw+10),yp,bw,bh); self.ToggleProcessingButton.clicked.connect(self.toggle_processing); yp+=vs
        # Exit Button
        self.ExitButton=self.create_button("üö™ Tho√°t"); self.ExitButton.setGeometry(bx,yp,bw,bh); self.ExitButton.clicked.connect(self.close_application)

        # --- Right Panel (Log, Status, Settings) ---
        rx = 670 # Right panel starting x
        lw = self.geometry().width()-rx-20 # Right panel width
        # Log Area
        log_label=QLabel("Log Ho·∫°t ƒê·ªông:",central_widget); log_label.setGeometry(rx,10,150,20);
        self.log_text_edit=QTextEdit(central_widget); self.log_text_edit.setGeometry(rx,35,lw,250); self.log_text_edit.setReadOnly(True); self.log_text_edit.setStyleSheet("border:1px solid black; padding:5px; background-color:white; font-family:Consolas,monospace; font-size:10pt;")
        # Status Labels
        self.process_label=QLabel("Tr·∫°ng th√°i: Ch·ªù",central_widget); self.process_label.setGeometry(rx,300,lw,40); self.process_label.setAlignment(Qt.AlignCenter); self.process_label.setStyleSheet("border:1px solid black; padding:5px; background-color:lightgray; font-weight:bold; border-radius:3px;")
        self.ssim_label=QLabel("SSIM: N/A",central_widget); self.ssim_label.setGeometry(rx,345,lw,30); self.ssim_label.setAlignment(Qt.AlignCenter); self.ssim_label.setStyleSheet("padding:5px; background-color:#f0f0f0; border-radius:3px;")

        # --- Settings Controls (Right Panel) ---
        sx_lbl = rx + 20      # Settings label x-pos
        sx_ctrl = sx_lbl + 160 # Settings control x-pos
        sy = 390              # Settings starting y-pos
        s_vs = 40             # Settings vertical spacing
        ctrl_w = 180          # Control width
        btn_w_sm = 40         # Small button width (refresh)

        # SSIM Threshold
        ls=QLabel("Ng∆∞·ª°ng SSIM:",central_widget); ls.setGeometry(sx_lbl,sy,150,31);
        self.ssimThresholdSpinBox=QDoubleSpinBox(central_widget); self.ssimThresholdSpinBox.setGeometry(sx_ctrl,sy,ctrl_w,31); self.ssimThresholdSpinBox.setRange(0.1,1.0); self.ssimThresholdSpinBox.setSingleStep(0.01); self.ssimThresholdSpinBox.setValue(self._current_ssim_threshold); self.ssimThresholdSpinBox.setDecimals(3); self.ssimThresholdSpinBox.valueChanged.connect(self._update_threshold_config); sy+=s_vs
        # Error Cooldown
        lc=QLabel("Cooldown L·ªói (s):",central_widget); lc.setGeometry(sx_lbl,sy,150,31);
        self.cooldownSpinBox=QSpinBox(central_widget); self.cooldownSpinBox.setGeometry(sx_ctrl,sy,ctrl_w,31); self.cooldownSpinBox.setRange(1,300); self.cooldownSpinBox.setSingleStep(1); self.cooldownSpinBox.setValue(self._current_error_cooldown); self.cooldownSpinBox.valueChanged.connect(self._update_cooldown_config); sy+=s_vs
        # Runtime Duration
        lr=QLabel("Th·ªùi gian ch·∫°y (ph√∫t):",central_widget); lr.setGeometry(sx_lbl,sy,150,31);
        self.runtimeSpinBox=QSpinBox(central_widget); self.runtimeSpinBox.setGeometry(sx_ctrl,sy,ctrl_w,31); self.runtimeSpinBox.setRange(0,1440); self.runtimeSpinBox.setSingleStep(10); self.runtimeSpinBox.setValue(self._current_runtime_minutes); self.runtimeSpinBox.setToolTip("0 = Ch·∫°y v√¥ h·∫°n"); self.runtimeSpinBox.valueChanged.connect(self._update_runtime_config); sy+=s_vs
        # Record on Error Toggle Button
        self.ToggleRecordOnErrorButton=self.create_button("üé• Quay video l·ªói: T·∫Øt"); self.ToggleRecordOnErrorButton.setGeometry(sx_lbl,sy,ctrl_w+50,31); self.ToggleRecordOnErrorButton.setCheckable(False); self.ToggleRecordOnErrorButton.clicked.connect(self._toggle_record_on_error); sy+=s_vs

        # --- Serial Port Settings ---
        # COM Port Selection
        lcp=QLabel("C·ªïng COM:",central_widget); lcp.setGeometry(sx_lbl,sy,150,31);
        self.comPortComboBox=QComboBox(central_widget); self.comPortComboBox.setGeometry(sx_ctrl,sy,ctrl_w-btn_w_sm-5,31); self.comPortComboBox.setToolTip("Ch·ªçn c·ªïng COM ƒë·ªÉ g·ª≠i t√≠n hi·ªáu"); self.comPortComboBox.currentTextChanged.connect(self._update_serial_port_config)
        # Refresh COM Ports Button
        self.refreshComButton=QPushButton("üîÑ",central_widget); self.refreshComButton.setGeometry(sx_ctrl+ctrl_w-btn_w_sm,sy,btn_w_sm,31); self.refreshComButton.setToolTip("L√†m m·ªõi danh s√°ch c·ªïng COM"); self.refreshComButton.clicked.connect(self._refresh_com_ports); sy+=s_vs
        # Baud Rate Selection
        lbr=QLabel("Baud Rate:",central_widget); lbr.setGeometry(sx_lbl,sy,150,31);
        self.baudRateComboBox=QComboBox(central_widget); self.baudRateComboBox.setGeometry(sx_ctrl,sy,ctrl_w,31); self.baudRateComboBox.addItems([str(br) for br in COMMON_BAUD_RATES]); self.baudRateComboBox.setToolTip("Ch·ªçn t·ªëc ƒë·ªô Baud"); self.baudRateComboBox.setCurrentText(str(self.serial_baud_rate)); self.baudRateComboBox.currentTextChanged.connect(self._update_serial_baud_config); sy+=s_vs
        # Toggle Serial Connection Button
        self.ToggleSerialPortButton=self.create_button("üîå K·∫øt n·ªëi COM"); self.ToggleSerialPortButton.setGeometry(sx_lbl,sy,ctrl_w+50,31); self.ToggleSerialPortButton.setCheckable(False); self.ToggleSerialPortButton.setToolTip("B·∫≠t/T·∫Øt g·ª≠i t√≠n hi·ªáu qua c·ªïng COM"); self.ToggleSerialPortButton.clicked.connect(self._toggle_serial_port)

        # --- Initial UI Update ---
        # G·ªçi c√°c h√†m c·∫≠p nh·∫≠t style ban ƒë·∫ßu sau khi t·∫•t c·∫£ widget ƒë√£ ƒë∆∞·ª£c t·∫°o
        self.update_button_styles()
        self.update_toggle_button_text()
        self.update_record_button_style()
        self.update_serial_button_style()

    def create_button(self, text): # Helper ƒë·ªÉ t·∫°o button chu·∫©n
        button = QPushButton(text, self.centralWidget())
        button.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed) # Cho ph√©p co gi√£n ngang
        return button

    def save_config(self):
        # Gom t·∫•t c·∫£ state hi·ªán t·∫°i v√†o dict config tr∆∞·ªõc khi l∆∞u
        self.config['ssim_threshold']=self._current_ssim_threshold
        self.config['error_cooldown']=self._current_error_cooldown
        self.config['runtime_duration_minutes']=self._current_runtime_minutes
        self.config['record_on_error']=self._record_on_error_enabled
        self.config['error_folder']=self.error_folder
        self.config['webcam_roi']=list(self.webcam_roi) if self.webcam_roi else None
        # ƒê·∫£m b·∫£o ch·ªâ l∆∞u ƒë∆∞·ªùng d·∫´n h·ª£p l·ªá trong ref_paths
        valid_ref_paths = {}
        for k, p in self.config['ref_paths'].items():
             if k in self.ref_images and isinstance(p, str) and os.path.isfile(p):
                 valid_ref_paths[k] = p
             elif k in self.ref_images and self.ref_images[k] is not None and p is None: # ·∫¢nh t·ª´ webcam
                 valid_ref_paths[k] = None # L∆∞u None ƒë·ªÉ bi·∫øt l√† t·ª´ webcam
             else: # Kh√¥ng c√≥ ·∫£nh ho·∫∑c ƒë∆∞·ªùng d·∫´n kh√¥ng h·ª£p l·ªá
                 valid_ref_paths[k] = None
        self.config['ref_paths'] = valid_ref_paths

        self.config['serial_port']=self.serial_port_name
        self.config['serial_baud']=self.serial_baud_rate
        self.config['serial_enabled']=self.serial_enabled # L∆∞u tr·∫°ng th√°i cu·ªëi c√πng

        try:
            config_dir=os.path.dirname(CONFIG_FILE_NAME)
            # T·∫°o th∆∞ m·ª•c config n·∫øu ch∆∞a c√≥ (ch·ªâ √°p d·ª•ng n·∫øu CONFIG_FILE_NAME c√≥ ƒë∆∞·ªùng d·∫´n)
            if config_dir and not os.path.exists(config_dir):
                try:
                    os.makedirs(config_dir, exist_ok=True)
                    self.log_activity(f"‚ÑπÔ∏è ƒê√£ t·∫°o th∆∞ m·ª•c c·∫•u h√¨nh: {config_dir}")
                except OSError as e:
                     self.log_activity(f"‚ùå L·ªói khi t·∫°o th∆∞ m·ª•c c·∫•u h√¨nh '{config_dir}': {e}")
                     QMessageBox.critical(self,"L·ªói L∆∞u Config",f"Kh√¥ng th·ªÉ t·∫°o th∆∞ m·ª•c ƒë·ªÉ l∆∞u c·∫•u h√¨nh:\n{config_dir}\nL·ªói: {e}")
                     return # Kh√¥ng th·ª≠ ghi file n·∫øu kh√¥ng t·∫°o ƒë∆∞·ª£c th∆∞ m·ª•c

            # Ghi file JSON
            with open(CONFIG_FILE_NAME,'w',encoding='utf-8') as f:
                json.dump(self.config, f, indent=4, ensure_ascii=False)
            # self.log_activity("üíæ C·∫•u h√¨nh ƒë√£ ƒë∆∞·ª£c l∆∞u.") # Log khi c·∫ßn thi·∫øt, v√≠ d·ª• khi ƒë√≥ng app

        except Exception as e:
            self.log_activity(f"‚ùå L·ªói nghi√™m tr·ªçng khi l∆∞u c·∫•u h√¨nh v√†o '{CONFIG_FILE_NAME}': {e}")
            self.log_activity(traceback.format_exc())
            QMessageBox.critical(self,"L·ªói L∆∞u Config",f"Kh√¥ng th·ªÉ l∆∞u c·∫•u h√¨nh v√†o file:\n{CONFIG_FILE_NAME}\n\nL·ªói: {e}")

    def load_config(self):
        if not os.path.exists(CONFIG_FILE_NAME):
            self.log_activity(f"üìÑ Kh√¥ng t√¨m th·∫•y file c·∫•u h√¨nh '{CONFIG_FILE_NAME}'. S·ª≠ d·ª•ng c√†i ƒë·∫∑t m·∫∑c ƒë·ªãnh."); self.reset_to_defaults(); return
        try:
            with open(CONFIG_FILE_NAME,'r',encoding='utf-8') as f: lcfg=json.load(f)

            # --- T·∫£i c√°c gi√° tr·ªã c∆° b·∫£n v·ªõi ki·ªÉm tra v√† gi√° tr·ªã m·∫∑c ƒë·ªãnh ---
            try: self._current_ssim_threshold=max(0.1,min(1.0,float(lcfg.get('ssim_threshold',DEFAULT_SSIM_THRESHOLD))))
            except (ValueError, TypeError): self._current_ssim_threshold=DEFAULT_SSIM_THRESHOLD; self.log_activity(f"‚ö†Ô∏è Gi√° tr·ªã ssim_threshold kh√¥ng h·ª£p l·ªá trong config, d√πng m·∫∑c ƒë·ªãnh ({DEFAULT_SSIM_THRESHOLD}).")
            try: self._current_error_cooldown=max(1,min(300,int(lcfg.get('error_cooldown',DEFAULT_ERROR_COOLDOWN))))
            except (ValueError, TypeError): self._current_error_cooldown=DEFAULT_ERROR_COOLDOWN; self.log_activity(f"‚ö†Ô∏è Gi√° tr·ªã error_cooldown kh√¥ng h·ª£p l·ªá trong config, d√πng m·∫∑c ƒë·ªãnh ({DEFAULT_ERROR_COOLDOWN}).")
            try: self._current_runtime_minutes=max(0,min(1440,int(lcfg.get('runtime_duration_minutes',DEFAULT_RUNTIME_MINUTES))))
            except (ValueError, TypeError): self._current_runtime_minutes=DEFAULT_RUNTIME_MINUTES; self.log_activity(f"‚ö†Ô∏è Gi√° tr·ªã runtime_duration_minutes kh√¥ng h·ª£p l·ªá trong config, d√πng m·∫∑c ƒë·ªãnh ({DEFAULT_RUNTIME_MINUTES}).")

            lrec=lcfg.get('record_on_error',DEFAULT_RECORD_ON_ERROR); self._record_on_error_enabled=bool(lrec) if isinstance(lrec,bool) else DEFAULT_RECORD_ON_ERROR

            # --- T·∫£i c√†i ƒë·∫∑t Serial ---
            self.serial_port_name=lcfg.get('serial_port',None)
            if not isinstance(self.serial_port_name, (str, type(None))): # ƒê·∫£m b·∫£o l√† string ho·∫∑c None
                self.log_activity(f"‚ö†Ô∏è Gi√° tr·ªã serial_port ('{self.serial_port_name}') kh√¥ng h·ª£p l·ªá, ƒë·∫∑t v·ªÅ None."); self.serial_port_name = None

            try:
                baud=int(lcfg.get('serial_baud',DEFAULT_BAUD_RATE));
                self.serial_baud_rate=baud if baud in COMMON_BAUD_RATES else DEFAULT_BAUD_RATE
                if baud not in COMMON_BAUD_RATES and 'serial_baud' in lcfg: # Log n·∫øu baud kh√¥ng chu·∫©n nh∆∞ng c√≥ trong config
                     self.log_activity(f"‚ö†Ô∏è Baud rate '{baud}' trong config kh√¥ng n·∫±m trong danh s√°ch ph·ªï bi·∫øn, d√πng m·∫∑c ƒë·ªãnh ({DEFAULT_BAUD_RATE}).")
            except (ValueError, TypeError): self.serial_baud_rate=DEFAULT_BAUD_RATE; self.log_activity(f"‚ö†Ô∏è Gi√° tr·ªã serial_baud kh√¥ng h·ª£p l·ªá trong config, d√πng m·∫∑c ƒë·ªãnh ({DEFAULT_BAUD_RATE}).")

            # T·∫£i tr·∫°ng th√°i serial_enabled, nh∆∞ng kh√¥ng t·ª± ƒë·ªông k·∫øt n·ªëi ·ªü ƒë√¢y.
            lse=lcfg.get('serial_enabled',DEFAULT_SERIAL_ENABLED); self.serial_enabled=bool(lse) if isinstance(lse,bool) else DEFAULT_SERIAL_ENABLED
            # Quan tr·ªçng: N·∫øu self.serial_enabled l√† True ·ªü ƒë√¢y, UI s·∫Ω hi·ªÉn th·ªã l√† "B·∫≠t" nh∆∞ng th·ª±c t·∫ø ch∆∞a k·∫øt n·ªëi.
            # Ng∆∞·ªùi d√πng c·∫ßn b·∫•m "Ng·∫Øt k·∫øt n·ªëi" r·ªìi "K·∫øt n·ªëi" l·∫°i, ho·∫∑c ta ph·∫£i th√™m logic t·ª± k·∫øt n·ªëi n·∫øu mu·ªën.
            # ƒê·ªÉ ƒë∆°n gi·∫£n, ta s·∫Ω reset self.serial_enabled v·ªÅ False sau khi load, b·∫Øt bu·ªôc ng∆∞·ªùi d√πng k·∫øt n·ªëi l·∫°i.
            if self.serial_enabled:
                 self.log_activity("‚ÑπÔ∏è Tr·∫°ng th√°i Serial 'B·∫≠t' ƒë∆∞·ª£c t·∫£i t·ª´ config. Vui l√≤ng k·∫øt n·ªëi l·∫°i th·ªß c√¥ng n·∫øu c·∫ßn.")
                 self.serial_enabled = False # B·∫Øt bu·ªôc k·∫øt n·ªëi l·∫°i

            # --- T·∫£i th∆∞ m·ª•c l·ªói ---
            lfold=lcfg.get('error_folder'); self.error_folder=None # Reset tr∆∞·ªõc khi load
            if lfold and isinstance(lfold,str):
                if os.path.isdir(lfold):
                    if os.access(lfold,os.W_OK): self.error_folder=lfold # Ch·ªâ ch·∫•p nh·∫≠n n·∫øu t·ªìn t·∫°i v√† ghi ƒë∆∞·ª£c
                    else: self.log_activity(f"‚ö†Ô∏è Kh√¥ng c√≥ quy·ªÅn ghi v√†o th∆∞ m·ª•c l·ªói ƒë√£ l∆∞u '{lfold}'. Th∆∞ m·ª•c l·ªói b·ªã v√¥ hi·ªáu h√≥a.")
                else: self.log_activity(f"‚ö†Ô∏è ƒê∆∞·ªùng d·∫´n th∆∞ m·ª•c l·ªói ƒë√£ l∆∞u '{lfold}' kh√¥ng t·ªìn t·∫°i ho·∫∑c kh√¥ng ph·∫£i th∆∞ m·ª•c. Th∆∞ m·ª•c l·ªói b·ªã v√¥ hi·ªáu h√≥a.")
            elif lfold: self.log_activity(f"‚ö†Ô∏è Gi√° tr·ªã error_folder ('{lfold}') trong config kh√¥ng h·ª£p l·ªá. Th∆∞ m·ª•c l·ªói b·ªã v√¥ hi·ªáu h√≥a.")

            # --- T·∫£i ROI ---
            lroi=lcfg.get('webcam_roi'); self.webcam_roi=None # Reset tr∆∞·ªõc khi load
            if isinstance(lroi,list) and len(lroi)==4:
                try:
                    rt=tuple(int(x) for x in lroi); # Chuy·ªÉn sang tuple s·ªë nguy√™n
                    if all(isinstance(v,int) and v>=0 for v in rt) and rt[2]>0 and rt[3]>0: # Ki·ªÉm tra h·ª£p l·ªá (>=0, w>0, h>0)
                        self.webcam_roi=rt
                    else: self.log_activity(f"‚ö†Ô∏è Gi√° tr·ªã ROI trong config kh√¥ng h·ª£p l·ªá (s·ªë √¢m ho·∫∑c w/h=0): {lroi}. ROI b·ªã v√¥ hi·ªáu h√≥a.")
                except (ValueError, TypeError): self.log_activity(f"‚ö†Ô∏è Gi√° tr·ªã ROI trong config kh√¥ng ph·∫£i s·ªë nguy√™n: {lroi}. ROI b·ªã v√¥ hi·ªáu h√≥a.")
            elif lroi is not None: self.log_activity(f"‚ö†Ô∏è ƒê·ªãnh d·∫°ng ROI trong config kh√¥ng h·ª£p l·ªá (kh√¥ng ph·∫£i list 4 ph·∫ßn t·ª≠): {lroi}. ROI b·ªã v√¥ hi·ªáu h√≥a.")

            # --- T·∫£i ƒë∆∞·ªùng d·∫´n ·∫£nh tham chi·∫øu v√† load ·∫£nh ---
            lrefs=lcfg.get('ref_paths',{}); self.config['ref_paths']={k:None for k in self.ref_images.keys()} # Reset trong config
            self.ref_images={k:None for k in self.ref_images.keys()} # Reset ·∫£nh ƒë√£ load
            loaded_image_keys = []
            for k in self.ref_images.keys(): # Duy·ªát qua c√°c key chu·∫©n (Norm, Shutdown, Fail)
                p = lrefs.get(k) # L·∫•y ƒë∆∞·ªùng d·∫´n t·ª´ config ƒë√£ t·∫£i
                if p and isinstance(p,str): # N·∫øu c√≥ ƒë∆∞·ªùng d·∫´n v√† l√† string
                    if os.path.isfile(p):
                        try:
                            ib=np.fromfile(p,dtype=np.uint8) # ƒê·ªçc an to√†n v·ªõi unicode path
                            img=cv2.imdecode(ib,cv2.IMREAD_COLOR)
                            if img is not None:
                                self.ref_images[k]=img # L∆∞u ·∫£nh ƒë√£ load
                                self.config['ref_paths'][k] = p # L∆∞u l·∫°i ƒë∆∞·ªùng d·∫´n h·ª£p l·ªá v√†o config hi·ªán t·∫°i
                                loaded_image_keys.append(k)
                            else: # File ƒë·ªçc ƒë∆∞·ª£c nh∆∞ng kh√¥ng decode ƒë∆∞·ª£c ·∫£nh
                                self.log_activity(f"‚ö†Ô∏è Kh√¥ng th·ªÉ gi·∫£i m√£ ·∫£nh '{k}' t·ª´ file ƒë√£ l∆∞u: {p}.");
                        except Exception as e: # L·ªói khi ƒë·ªçc file
                            self.log_activity(f"‚ùå L·ªói khi t·∫£i ·∫£nh '{k}' t·ª´ file ƒë√£ l∆∞u {p}: {e}");
                    else: # ƒê∆∞·ªùng d·∫´n c√≥ nh∆∞ng kh√¥ng ph·∫£i file
                        self.log_activity(f"‚ö†Ô∏è File ·∫£nh '{k}' ƒë√£ l∆∞u kh√¥ng t·ªìn t·∫°i ho·∫∑c kh√¥ng ph·∫£i file: {p}");
                elif p is None and k in lrefs: # ƒê∆∞·ªùng d·∫´n l√† None -> c√≥ th·ªÉ l√† ·∫£nh ch·ª•p t·ª´ webcam c≈©
                    # Kh√¥ng c·∫ßn load g√¨ c·∫£, ch·ªâ c·∫ßn bi·∫øt l√† kh√¥ng c√≥ file
                    pass
                elif p: # ƒê∆∞·ªùng d·∫´n c√≥ nh∆∞ng kh√¥ng ph·∫£i string
                     self.log_activity(f"‚ö†Ô∏è ƒê∆∞·ªùng d·∫´n ·∫£nh '{k}' trong config kh√¥ng h·ª£p l·ªá (kh√¥ng ph·∫£i string): {p}");

            # Log c√°c ·∫£nh ƒë√£ t·∫£i th√†nh c√¥ng (sau v√≤ng l·∫∑p ƒë·ªÉ tr√°nh spam)
            if loaded_image_keys:
                self.log_activity(f"‚úÖ ƒê√£ t·∫£i th√†nh c√¥ng ·∫£nh tham chi·∫øu t·ª´ file cho: {', '.join(loaded_image_keys)}")

            # --- C·∫≠p nh·∫≠t dict config cu·ªëi c√πng v√† ƒë∆∞·ªùng d·∫´n log ---
            # (ƒê·∫£m b·∫£o config ph·∫£n √°nh ƒë√∫ng state sau khi load v√† validate)
            self.config.update({
                'ssim_threshold':self._current_ssim_threshold, 'error_cooldown':self._current_error_cooldown,
                'runtime_duration_minutes':self._current_runtime_minutes, 'record_on_error':self._record_on_error_enabled,
                'error_folder':self.error_folder, 'webcam_roi':list(self.webcam_roi) if self.webcam_roi else None,
                'serial_port':self.serial_port_name, 'serial_baud':self.serial_baud_rate,
                'serial_enabled':self.serial_enabled # S·∫Ω lu√¥n l√† False sau khi load
                # ref_paths ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t trong v√≤ng l·∫∑p tr√™n
            })

            self.log_file_path=os.path.join(self.error_folder,LOG_FILE_NAME) if self.error_folder else None
            self.log_activity(f"üíæ ƒê√£ t·∫£i c·∫•u h√¨nh t·ª´ '{CONFIG_FILE_NAME}'.")

        except json.JSONDecodeError as e:
            self.log_activity(f"‚ùå L·ªói ph√¢n t√≠ch JSON trong file c·∫•u h√¨nh '{CONFIG_FILE_NAME}': {e}. S·ª≠ d·ª•ng c√†i ƒë·∫∑t m·∫∑c ƒë·ªãnh."); self.reset_to_defaults()
        except Exception as e:
            self.log_activity(f"‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh khi t·∫£i c·∫•u h√¨nh: {e}."); self.log_activity(traceback.format_exc()); self.reset_to_defaults()

    def reset_to_defaults(self):
        self.log_activity("üîÑ ƒêang reset v·ªÅ c√†i ƒë·∫∑t m·∫∑c ƒë·ªãnh...")
        # Reset state variables
        self._current_ssim_threshold=DEFAULT_SSIM_THRESHOLD
        self._current_error_cooldown=DEFAULT_ERROR_COOLDOWN
        self._current_runtime_minutes=DEFAULT_RUNTIME_MINUTES
        self._record_on_error_enabled=DEFAULT_RECORD_ON_ERROR
        self.error_folder=None
        self.log_file_path=None
        self.webcam_roi=None
        self.ref_images={k:None for k in[REF_NORM,REF_SHUTDOWN,REF_FAIL]}
        self.serial_port_name=None
        self.serial_baud_rate=DEFAULT_BAUD_RATE
        self.serial_enabled=False # Lu√¥n t·∫Øt khi reset

        # ƒê√≥ng c·ªïng serial n·∫øu ƒëang m·ªü
        if self.serial_port and self.serial_port.is_open:
            try: self.serial_port.close()
            except: pass # B·ªè qua l·ªói khi ƒë√≥ng ·ªü ƒë√¢y
        self.serial_port=None

        # Reset config dictionary
        self.config={
            'ssim_threshold':self._current_ssim_threshold, 'error_cooldown':self._current_error_cooldown,
            'runtime_duration_minutes':self._current_runtime_minutes, 'record_on_error':self._record_on_error_enabled,
            'error_folder':None, 'ref_paths':{k:None for k in[REF_NORM,REF_SHUTDOWN,REF_FAIL]},
            'webcam_roi':None, 'serial_port':self.serial_port_name,
            'serial_baud':self.serial_baud_rate, 'serial_enabled':self.serial_enabled,
            }

        # Sau khi reset, c·∫ßn c·∫≠p nh·∫≠t l·∫°i UI v√† l∆∞u config m·∫∑c ƒë·ªãnh m·ªõi
        # C·∫ßn ƒë·∫£m b·∫£o UI ƒë√£ ƒë∆∞·ª£c init tr∆∞·ªõc khi g·ªçi update_all_ui_elements
        if hasattr(self, 'ssimThresholdSpinBox'): # Ki·ªÉm tra xem init_ui ƒë√£ ch·∫°y ch∆∞a
             self.update_all_ui_elements()
             self.save_config() # L∆∞u l·∫°i config m·∫∑c ƒë·ªãnh
             self.log_activity("üîÑ ƒê√£ ho√†n t·∫•t reset v·ªÅ m·∫∑c ƒë·ªãnh v√† c·∫≠p nh·∫≠t giao di·ªán.")
        else:
             self.log_activity("üîÑ ƒê√£ ho√†n t·∫•t reset v·ªÅ m·∫∑c ƒë·ªãnh (UI ch∆∞a s·∫µn s√†ng ƒë·ªÉ c·∫≠p nh·∫≠t).")


    def update_all_ui_elements(self):
        self.log_activity("‚ÑπÔ∏è ƒêang c·∫≠p nh·∫≠t giao di·ªán ng∆∞·ªùi d√πng...")
        # Block signals ƒë·ªÉ tr√°nh k√≠ch ho·∫°t slot khi set gi√° tr·ªã
        controls_to_block = [
            self.ssimThresholdSpinBox, self.cooldownSpinBox, self.runtimeSpinBox,
            self.comPortComboBox, self.baudRateComboBox
        ]
        for control in controls_to_block: control.blockSignals(True)

        # C·∫≠p nh·∫≠t gi√° tr·ªã t·ª´ state/config
        self.ssimThresholdSpinBox.setValue(self._current_ssim_threshold)
        self.cooldownSpinBox.setValue(self._current_error_cooldown)
        self.runtimeSpinBox.setValue(self._current_runtime_minutes)
        self.baudRateComboBox.setCurrentText(str(self.serial_baud_rate))

        # C·∫≠p nh·∫≠t COM port combo box (n√™n g·ªçi refresh tr∆∞·ªõc ƒë√≥)
        # self._refresh_com_ports() # ƒê√£ g·ªçi ·ªü init, kh√¥ng g·ªçi l·∫°i ·ªü ƒë√¢y ƒë·ªÉ tr√°nh x√≥a log kh·ªüi ƒë·ªông
        current_com_text = self.comPortComboBox.currentText()
        com_index = self.comPortComboBox.findText(self.serial_port_name if self.serial_port_name else "")
        if self.serial_port_name and com_index >= 0:
             self.comPortComboBox.setCurrentIndex(com_index)
        elif self.comPortComboBox.count() > 0 and "Kh√¥ng t√¨m th·∫•y" not in self.comPortComboBox.itemText(0):
             # N·∫øu c·ªïng ƒë√£ l∆∞u kh√¥ng c√≥ nh∆∞ng c√≥ c·ªïng kh√°c, ch·ªçn c·ªïng ƒë·∫ßu ti√™n
             first_available_port = self.comPortComboBox.itemText(0)
             self.comPortComboBox.setCurrentIndex(0)
             if self.serial_port_name != first_available_port:
                  # self.log_activity(f"‚ö†Ô∏è C·ªïng COM ƒë√£ l∆∞u '{self.serial_port_name}' kh√¥ng t√¨m th·∫•y. Ch·ªçn c·ªïng '{first_available_port}'.") # Log khi refresh r√µ h∆°n
                  self.serial_port_name = first_available_port
                  self.config['serial_port'] = first_available_port
        # else: N·∫øu kh√¥ng c√≥ c·ªïng n√†o, comPortComboBox ƒë√£ b·ªã disable b·ªüi refresh

        # Unblock signals
        for control in controls_to_block: control.blockSignals(False)

        # C·∫≠p nh·∫≠t style c√°c n√∫t
        self.update_button_styles()
        self.update_toggle_button_text()
        self.update_record_button_style()
        self.update_serial_button_style()

        # K√≠ch ho·∫°t/V√¥ hi·ªáu h√≥a c√°c control d·ª±a tr√™n tr·∫°ng th√°i processing v√† serial
        self.disable_settings_while_processing(self.processing)

        # Log tr·∫°ng th√°i ban ƒë·∫ßu (ch·ªâ log 1 l·∫ßn khi update UI sau load/reset)
        # (ƒê√£ chuy·ªÉn ph·∫ßn log ·∫£nh/folder/ROI/Serial v√†o load_config v√† c√°c h√†m thay ƒë·ªïi t∆∞∆°ng ·ª©ng)
        self.log_activity("‚ÑπÔ∏è Giao di·ªán ng∆∞·ªùi d√πng ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t.")


    @QtCore.pyqtSlot(str)
    def log_activity(self, message):
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S"); full_message = f"{timestamp} - {message}"

        # ƒê·∫£m b·∫£o c·∫≠p nh·∫≠t QTextEdit t·ª´ ƒë√∫ng lu·ªìng
        if hasattr(self, 'log_text_edit'): # Ki·ªÉm tra widget t·ªìn t·∫°i
            if self.log_text_edit.thread() != QtCore.QThread.currentThread():
                QtCore.QMetaObject.invokeMethod(self.log_text_edit, "append", QtCore.Qt.QueuedConnection, QtCore.Q_ARG(str, full_message))
                QtCore.QMetaObject.invokeMethod(self.log_text_edit, "ensureCursorVisible", QtCore.Qt.QueuedConnection)
            else:
                self.log_text_edit.append(full_message)
                self.log_text_edit.ensureCursorVisible()

        # Ghi v√†o file log
        if self.log_file_path:
            try:
                log_dir = os.path.dirname(self.log_file_path)
                # Ki·ªÉm tra v√† t·∫°o th∆∞ m·ª•c n·∫øu ch∆∞a c√≥
                if log_dir and not os.path.exists(log_dir):
                     try:
                         os.makedirs(log_dir, exist_ok=True)
                     except OSError as mkdir_e:
                         print(f"CRITICAL: Cannot create log directory '{log_dir}'. Error: {mkdir_e}. Disabling file logging.")
                         self.log_file_path=None # V√¥ hi·ªáu h√≥a ghi file
                         return # Kh√¥ng th·ª≠ ghi n·ªØa

                # Ghi v√†o file (ch·ªâ khi log_file_path v·∫´n h·ª£p l·ªá)
                if self.log_file_path:
                    with open(self.log_file_path, "a", encoding="utf-8") as log_file:
                        log_file.write(full_message + "\n")

            except Exception as e:
                print(f"CRITICAL: Error writing to log file '{self.log_file_path}'. Error: {e}. Disabling file logging.")
                self.log_file_path = None # V√¥ hi·ªáu h√≥a ghi file
        # else: # Kh√¥ng c√≥ ƒë∆∞·ªùng d·∫´n log (ch∆∞a ch·ªçn folder l·ªói) -> ch·ªâ hi·ªÉn th·ªã tr√™n UI
             # pass


    @QtCore.pyqtSlot(str, str)
    def update_status_label(self, message, background_color="lightgray"):
        # S·ª≠ d·ª•ng lambda ƒë·ªÉ tr√°nh l·ªói pickling khi d√πng invokeMethod v·ªõi h√†m l·ªìng nhau
        _update = lambda: (
            self.process_label.setText(f"Tr·∫°ng th√°i: {message}"),
            self.process_label.setStyleSheet(f"border:1px solid black; padding:5px; background-color:{background_color}; color:black; font-weight:bold; border-radius:3px;")
        )
        if self.process_label.thread()!=QtCore.QThread.currentThread():
             # D√πng invokeMethod ƒë·ªÉ g·ªçi lambda _update tr√™n lu·ªìng ch√≠nh
             # C·∫ßn m·ªôt slot trung gian ƒë·ªÉ g·ªçi lambda
             QtCore.QMetaObject.invokeMethod(self, "_call_lambda_slot", QtCore.Qt.QueuedConnection, QtCore.Q_ARG(object, _update))
        else: _update()

    @QtCore.pyqtSlot(float)
    def update_ssim_display(self, score):
         _update = lambda: self.ssim_label.setText(f"SSIM: {score:.4f}" if score is not None and score>=0 else "SSIM: N/A")
         if self.ssim_label.thread()!=QtCore.QThread.currentThread():
             QtCore.QMetaObject.invokeMethod(self, "_call_lambda_slot", QtCore.Qt.QueuedConnection, QtCore.Q_ARG(object, _update))
         else: _update()

    # Slot trung gian ƒë·ªÉ g·ªçi h√†m lambda t·ª´ lu·ªìng kh√°c
    @QtCore.pyqtSlot(object)
    def _call_lambda_slot(self, f):
        f()


    def _set_button_style(self, button, base_text, icon, state_text="", background_color="white", text_color="black"):
        full_text=f"{icon} {base_text}"+ (f" ({state_text})" if state_text else "")
        button.setText(full_text)
        style=f"""
            QPushButton {{
                background-color: {background_color};
                color: {text_color};
                padding: 6px;
                text-align: center;
                border: 1px solid #ccc;
                border-radius: 3px;
            }}
            QPushButton:hover {{
                background-color: #e8f0fe; /* M√†u xanh nh·∫°t khi hover */
            }}
            QPushButton:pressed {{
                background-color: #d0e0f8; /* M√†u xanh ƒë·∫≠m h∆°n khi nh·∫•n */
            }}
            QPushButton:disabled {{
                background-color: #f0f0f0; /* M√†u x√°m khi b·ªã v√¥ hi·ªáu h√≥a */
                color: #a0a0a0;
                border-color: #d0d0d0;
            }}
        """
        button.setStyleSheet(style)

    def update_button_styles(self):
        # Dict √°nh x·∫° key (Norm, Shutdown, Fail) t·ªõi n√∫t Load v√† Capture t∆∞∆°ng ·ª©ng
        button_load_map={
            REF_NORM: self.SettingButton_Norm,
            REF_SHUTDOWN: self.SettingButton_Shutdown,
            REF_FAIL: self.SettingButton_Fail
        }
        button_capture_map={
            REF_NORM: self.CaptureButton_Norm,
            REF_SHUTDOWN: self.CaptureButton_Shut,
            REF_FAIL: self.CaptureButton_Fail
        }
        # Icons v√† Text cho c√°c n√∫t
        icon_load="üìÇ"; icon_capture="üì∏"
        text_load={"Norm":"·∫¢nh Norm","Shutdown":"·∫¢nh Shutdown","Fail":"·∫¢nh Fail"}
        text_capture={"Norm":"Ch·ª•p Norm","Shutdown":"Ch·ª•p Shutdown","Fail":"Ch·ª•p Fail"}

        # C·∫≠p nh·∫≠t style cho t·ª´ng c·∫∑p n√∫t Load/Capture
        for key in self.ref_images.keys():
            load_button = button_load_map[key]
            capture_button = button_capture_map[key]
            has_image = isinstance(self.ref_images.get(key), np.ndarray) and self.ref_images[key].size > 0
            is_from_file = has_image and isinstance(self.config['ref_paths'].get(key), str) # Ki·ªÉm tra c√≥ ƒë∆∞·ªùng d·∫´n file kh√¥ng

            if has_image:
                if is_from_file: # ·∫¢nh t·ª´ file
                    self._set_button_style(load_button, text_load[key], icon_load, "File", "lightgreen") # N√∫t Load n·ªïi b·∫≠t
                    self._set_button_style(capture_button, text_capture[key], icon_capture) # N√∫t Capture b√¨nh th∆∞·ªùng
                else: # ·∫¢nh t·ª´ webcam capture (path l√† None)
                    self._set_button_style(load_button, text_load[key], icon_load) # N√∫t Load b√¨nh th∆∞·ªùng
                    self._set_button_style(capture_button, text_capture[key], icon_capture, "Webcam", "lightblue") # N√∫t Capture n·ªïi b·∫≠t
            else: # Ch∆∞a c√≥ ·∫£nh
                self._set_button_style(load_button, text_load[key], icon_load) # N√∫t Load b√¨nh th∆∞·ªùng
                self._set_button_style(capture_button, text_capture[key], icon_capture) # N√∫t Capture b√¨nh th∆∞·ªùng

        # C·∫≠p nh·∫≠t n√∫t ROI
        if self.webcam_roi: self._set_button_style(self.SettingButton_ROI_Webcam,"Ch·ªçn ROI","‚úÇÔ∏è","ƒê√£ ch·ªçn","lightblue")
        else: self._set_button_style(self.SettingButton_ROI_Webcam,"Ch·ªçn ROI","‚úÇÔ∏è")

        # C·∫≠p nh·∫≠t n√∫t Th∆∞ m·ª•c l·ªói
        if self.error_folder: self._set_button_style(self.SaveButton,"Th∆∞ m·ª•c l·ªói","üìÅ","ƒê√£ ch·ªçn","lightblue")
        else: self._set_button_style(self.SaveButton,"Th∆∞ m·ª•c l·ªói","üìÅ")

    def update_toggle_button_text(self):
        if self.processing:
            self._set_button_style(self.ToggleProcessingButton,"D·ª´ng X·ª≠ l√Ω","‚èπ", background_color="orange")
        else:
            self._set_button_style(self.ToggleProcessingButton,"B·∫Øt ƒë·∫ßu","‚ñ∂Ô∏è", background_color="lightgreen")

    def update_record_button_style(self):
        if self._record_on_error_enabled:
            self._set_button_style(self.ToggleRecordOnErrorButton,"Quay video l·ªói","üé•","B·∫≠t","lightcoral")
        else:
            self._set_button_style(self.ToggleRecordOnErrorButton,"Quay video l·ªói","üé•","T·∫Øt","lightgray")

    def update_serial_button_style(self):
        if self.serial_enabled:
            self._set_button_style(self.ToggleSerialPortButton,"Ng·∫Øt k·∫øt n·ªëi COM","üîå","ƒêang k·∫øt n·ªëi","lightcoral") # ƒê·ªè khi ƒëang b·∫≠t
        else:
            # Ki·ªÉm tra c√≥ c·ªïng COM kh·∫£ d·ª•ng kh√¥ng
            has_ports = self.comPortComboBox.count() > 0 and "Kh√¥ng t√¨m th·∫•y" not in self.comPortComboBox.itemText(0)
            if has_ports:
                 self._set_button_style(self.ToggleSerialPortButton,"K·∫øt n·ªëi COM","üîå","Ch∆∞a k·∫øt n·ªëi","lightgreen") # Xanh n·∫øu c√≥ th·ªÉ k·∫øt n·ªëi
            else:
                 self._set_button_style(self.ToggleSerialPortButton,"K·∫øt n·ªëi COM","üîå","Kh√¥ng c√≥ c·ªïng","lightgray") # X√°m n·∫øu kh√¥ng c√≥ c·ªïng


    def start_webcam(self):
        if self.cap is not None and self.cap.isOpened():
            self.log_activity("‚ö†Ô∏è Webcam ƒë√£ ƒë∆∞·ª£c b·∫≠t."); return
        try:
            # Th·ª≠ c√°c backend ph·ªï bi·∫øn
            backends=[cv2.CAP_DSHOW, cv2.CAP_MSMF, None] # ∆Øu ti√™n DSHOW, MSMF tr√™n Windows
            self.cap=None
            opened_backend = "N/A"

            for bk in backends:
                api_pref = bk if bk is not None else cv2.CAP_ANY
                try:
                    tc=cv2.VideoCapture(0, api_pref)
                    if tc and tc.isOpened():
                        ret_test, _ = tc.read() # Th·ª≠ ƒë·ªçc 1 frame
                        if ret_test:
                            self.cap=tc
                            opened_backend = self.cap.getBackendName()
                            break # ƒê√£ m·ªü th√†nh c√¥ng, tho√°t v√≤ng l·∫∑p
                        else:
                           tc.release()
                           self.log_activity(f"‚ÑπÔ∏è Webcam backend {api_pref} m·ªü ƒë∆∞·ª£c nh∆∞ng kh√¥ng ƒë·ªçc ƒë∆∞·ª£c frame.")
                    elif tc: tc.release()
                except Exception as cam_err:
                    # Log l·ªói chi ti·∫øt h∆°n khi th·ª≠ t·ª´ng backend
                    self.log_activity(f"‚ÑπÔ∏è L·ªói khi th·ª≠ m·ªü webcam v·ªõi backend {api_pref}: {cam_err}")
                    if tc: tc.release()

            if self.cap is None:
                 raise IOError("Kh√¥ng th·ªÉ m·ªü webcam v·ªõi b·∫•t k·ª≥ backend n√†o ho·∫∑c kh√¥ng ƒë·ªçc ƒë∆∞·ª£c frame ban ƒë·∫ßu.")

            # --- ƒê√£ m·ªü webcam th√†nh c√¥ng ---
            fps_req=15.0 # FPS mong mu·ªën
            self.cap.set(cv2.CAP_PROP_FPS, fps_req)
            actual_fps=self.cap.get(cv2.CAP_PROP_FPS)
            if actual_fps <= 0: actual_fps=15.0 # M·∫∑c ƒë·ªãnh n·∫øu kh√¥ng l·∫•y ƒë∆∞·ª£c FPS
            self.webcam_fps = actual_fps
            timer_interval = max(33, int(1000 / self.webcam_fps)) # ms, t·ªëi thi·ªÉu ~30fps

            w=int(self.cap.get(cv2.CAP_PROP_FRAME_WIDTH))
            h=int(self.cap.get(cv2.CAP_PROP_FRAME_HEIGHT))

            self.log_activity(f"üöÄ Webcam ƒë√£ b·∫≠t (Backend: {opened_backend}, Resolution: {w}x{h}, FPS: {self.webcam_fps:.1f}, Interval: {timer_interval}ms)")

            self.frame_timer.start(timer_interval) # B·∫Øt ƒë·∫ßu timer ƒë·ªçc frame
            self.ONCam.setEnabled(False); self.OFFCam.setEnabled(True) # C·∫≠p nh·∫≠t n√∫t b·∫≠t/t·∫Øt cam
            self.graphicsView.setBackgroundBrush(QtGui.QBrush(Qt.black)) # N·ªÅn ƒëen khi c√≥ video

            # K√≠ch ho·∫°t c√°c n√∫t li√™n quan ƒë·∫øn webcam (n·∫øu kh√¥ng ƒëang x·ª≠ l√Ω)
            is_processing = self.processing
            self.SettingButton_ROI_Webcam.setEnabled(not is_processing)
            self.CaptureButton_Norm.setEnabled(not is_processing)
            self.CaptureButton_Shut.setEnabled(not is_processing)
            self.CaptureButton_Fail.setEnabled(not is_processing)

        except Exception as e:
            emsg=f"‚ùå L·ªói nghi√™m tr·ªçng khi b·∫≠t webcam: {e}"
            self.log_activity(emsg)
            self.log_activity(traceback.format_exc()) # Log traceback ƒë·ªÉ debug
            QMessageBox.critical(self,"L·ªói Webcam",f"Kh√¥ng th·ªÉ kh·ªüi ƒë·ªông webcam.\nChi ti·∫øt: {e}");
            if self.cap: self.cap.release(); self.cap=None;
            # ƒê·∫£m b·∫£o c√°c n√∫t ·ªü tr·∫°ng th√°i ƒë√∫ng khi c√≥ l·ªói
            self.ONCam.setEnabled(True); self.OFFCam.setEnabled(False)
            self.SettingButton_ROI_Webcam.setEnabled(False)
            self.CaptureButton_Norm.setEnabled(False)
            self.CaptureButton_Shut.setEnabled(False)
            self.CaptureButton_Fail.setEnabled(False)
            self.graphicsView.setBackgroundBrush(QtGui.QBrush(Qt.darkGray)) # N·ªÅn x√°m


    def update_frame(self):
        if self.cap is None or not self.cap.isOpened(): return # Tho√°t n·∫øu cam ch∆∞a s·∫µn s√†ng

        ret,frame=self.cap.read() # ƒê·ªçc frame
        if not ret or frame is None: # Ki·ªÉm tra ƒë·ªçc l·ªói
            current_time = time.time()
            if not hasattr(self,'last_read_error_time') or current_time - getattr(self,'last_read_error_time', 0) > 5: # Log ƒë·ªãnh k·ª≥
                self.log_activity("‚ö†Ô∏è L·ªói ƒë·ªçc frame t·ª´ webcam.")
                setattr(self,'last_read_error_time', current_time)
            return # Kh√¥ng c√≥ frame ƒë·ªÉ x·ª≠ l√Ω

        # ƒê√£ c√≥ frame, x√≥a timer l·ªói ƒë·ªçc n·∫øu c√≥
        if hasattr(self,'last_read_error_time'): delattr(self, 'last_read_error_time')

        try:
            display_frame=frame.copy() # Frame ƒë·ªÉ hi·ªÉn th·ªã (c√≥ th·ªÉ v·∫Ω ROI l√™n)
            processing_frame=frame     # Frame ƒë·ªÉ x·ª≠ l√Ω (nguy√™n g·ªëc ho·∫∑c ƒë√£ crop ROI)

            # --- √Åp d·ª•ng ROI n·∫øu c√≥ ---
            if self.webcam_roi:
                x,y,w,h=self.webcam_roi
                frame_h, frame_w = frame.shape[:2]
                x1, y1 = max(0, x), max(0, y) # G√≥c tr√™n tr√°i
                x2, y2 = min(frame_w, x + w), min(frame_h, y + h) # G√≥c d∆∞·ªõi ph·∫£i
                if x2 > x1 and y2 > y1: # ROI h·ª£p l·ªá
                    processing_frame = frame[y1:y2, x1:x2] # Crop frame ƒë·ªÉ x·ª≠ l√Ω
                    cv2.rectangle(display_frame, (x1, y1), (x2, y2), (0, 255, 0), 2) # V·∫Ω ROI l√™n frame hi·ªÉn th·ªã
                else: # ROI kh√¥ng h·ª£p l·ªá (v√≠ d·ª• ngo√†i khung h√¨nh)
                    current_time = time.time()
                    if not hasattr(self,'last_roi_invalid_time') or current_time - getattr(self,'last_roi_invalid_time', 0) > 10: # Log ƒë·ªãnh k·ª≥
                        self.log_activity(f"‚ö†Ô∏è ROI {self.webcam_roi} kh√¥ng h·ª£p l·ªá v·ªõi k√≠ch th∆∞·ªõc frame {frame_w}x{frame_h}. S·ª≠ d·ª•ng frame ƒë·∫ßy ƒë·ªß.")
                        setattr(self,'last_roi_invalid_time', current_time)
                    processing_frame = frame # S·ª≠ d·ª•ng frame ƒë·∫ßy ƒë·ªß n·∫øu ROI l·ªói
            else: # Kh√¥ng c√≥ ROI, x√≥a timer l·ªói n·∫øu c√≥
                 if hasattr(self,'last_roi_invalid_time'): delattr(self, 'last_roi_invalid_time')

            # --- Hi·ªÉn th·ªã frame ---
            frame_rgb = cv2.cvtColor(display_frame, cv2.COLOR_BGR2RGB) # Chuy·ªÉn BGR sang RGB cho QImage
            h, w, ch = frame_rgb.shape
            bytes_per_line = ch * w
            qt_image = QtGui.QImage(frame_rgb.data, w, h, bytes_per_line, QtGui.QImage.Format_RGB888)
            view_size = self.graphicsView.viewport().size() # K√≠ch th∆∞·ªõc c·ªßa viewport
            pixmap = QtGui.QPixmap.fromImage(qt_image).scaled(
                view_size - QtCore.QSize(2, 2), # Scale ƒë·ªÉ v·ª´a viewport (tr·ª´ vi·ªÅn)
                Qt.KeepAspectRatio, Qt.SmoothTransformation
            )

            # C·∫≠p nh·∫≠t QGraphicsPixmapItem
            if self.pixmap_item is None: # L·∫ßn ƒë·∫ßu hi·ªÉn th·ªã
                self.pixmap_item=QtWidgets.QGraphicsPixmapItem(pixmap)
                self.scene.addItem(self.pixmap_item)
                self.graphicsView.fitInView(self.pixmap_item, Qt.KeepAspectRatio) # CƒÉn gi·ªØa
            else: # C·∫≠p nh·∫≠t pixmap ƒë√£ c√≥
                self.pixmap_item.setPixmap(pixmap)
                # C√≥ th·ªÉ g·ªçi fitInView l·∫°i n·∫øu mu·ªën t·ª± ƒë·ªông cƒÉn gi·ªØa khi resize c·ª≠a s·ªï
                # self.graphicsView.fitInView(self.pixmap_item, Qt.KeepAspectRatio)

            # --- G·ª≠i frame cho worker n·∫øu ƒëang x·ª≠ l√Ω ---
            if self.processing:
                frame_to_process = processing_frame.copy() # T·∫°o b·∫£n sao cho worker

                # --- X·ª≠ l√Ω ghi video ---
                if self._record_on_error_enabled:
                    # Kh·ªüi t·∫°o VideoWriter n·∫øu ch∆∞a c√≥ v√† c·∫ßn ghi
                    if self.video_writer is None:
                        if self.error_folder and os.path.isdir(self.error_folder): # C·∫ßn th∆∞ m·ª•c l·ªói
                            try:
                                vid_h, vid_w = frame_to_process.shape[:2] # K√≠ch th∆∞·ªõc video = k√≠ch th∆∞·ªõc frame x·ª≠ l√Ω
                                video_dir = os.path.join(self.error_folder, VIDEO_SUBFOLDER)
                                os.makedirs(video_dir, exist_ok=True) # T·∫°o th∆∞ m·ª•c con n·∫øu ch∆∞a c√≥
                                timestamp = time.strftime('%Y%m%d_%H%M%S')
                                video_filename = f"error_recording_{timestamp}.mp4"
                                self.current_video_path = os.path.join(video_dir, video_filename)
                                fourcc = cv2.VideoWriter_fourcc(*'mp4v') # Codec MP4
                                self.video_writer = cv2.VideoWriter(self.current_video_path, fourcc, self.webcam_fps, (vid_w, vid_h))

                                if self.video_writer.isOpened():
                                    self.log_activity(f"üî¥ B·∫Øt ƒë·∫ßu ghi video l·ªói: {video_filename}")
                                    self.error_occurred_during_recording = False # Reset c·ªù l·ªói khi b·∫Øt ƒë·∫ßu video m·ªõi
                                else: # Kh√¥ng m·ªü ƒë∆∞·ª£c writer
                                    self.log_activity(f"‚ùå Kh√¥ng th·ªÉ kh·ªüi t·∫°o VideoWriter cho file: {video_filename}")
                                    self.video_writer=None; self.current_video_path=None
                            except Exception as e: # L·ªói nghi√™m tr·ªçng khi t·∫°o writer
                                self.log_activity(f"‚ùå L·ªói nghi√™m tr·ªçng khi kh·ªüi t·∫°o VideoWriter: {e}")
                                self.log_activity(traceback.format_exc())
                                self.video_writer=None; self.current_video_path=None
                        else: # Ch∆∞a c√≥ th∆∞ m·ª•c l·ªói
                            current_time = time.time()
                            if not hasattr(self,'last_video_folder_error') or current_time - getattr(self,'last_video_folder_error', 0) > 30: # Log ƒë·ªãnh k·ª≥
                                self.log_activity("‚ö†Ô∏è Ch∆∞a ƒë·∫∑t th∆∞ m·ª•c l·ªói h·ª£p l·ªá ƒë·ªÉ ghi video.")
                                setattr(self,'last_video_folder_error', current_time)

                    # Ghi frame v√†o video n·∫øu VideoWriter ƒë√£ s·∫µn s√†ng
                    if self.video_writer and self.video_writer.isOpened():
                        try:
                            # Kh√¥ng c·∫ßn resize v√¨ video t·∫°o theo k√≠ch th∆∞·ªõc frame x·ª≠ l√Ω
                            self.video_writer.write(frame_to_process)
                        except Exception as e:
                            self.log_activity(f"‚ùå L·ªói khi ghi frame v√†o video: {e}")
                            # C√¢n nh·∫Øc d·ª´ng ghi n·∫øu l·ªói li√™n t·ª•c?

                # --- ƒê∆∞a frame v√†o queue cho worker ---
                if not self.frame_queue.full():
                    try:
                        self.frame_queue.put(frame_to_process, block=False) # Non-blocking put
                        if hasattr(self,'last_queue_full_time'): delattr(self, 'last_queue_full_time') # X√≥a log queue ƒë·∫ßy n·∫øu th√†nh c√¥ng
                        if hasattr(self,'last_queue_put_error_time'): delattr(self, 'last_queue_put_error_time')
                    except Exception as e: # L·ªói khi put (hi·∫øm)
                         current_time = time.time()
                         if not hasattr(self,'last_queue_put_error_time') or current_time - getattr(self,'last_queue_put_error_time', 0) > 5: # Log ƒë·ªãnh k·ª≥
                             self.log_activity(f"‚ùå L·ªói khi ƒë∆∞a frame v√†o queue: {e}")
                             setattr(self,'last_queue_put_error_time', current_time)
                else: # Queue ƒë·∫ßy
                    current_time = time.time()
                    if not hasattr(self,'last_queue_full_time') or current_time - getattr(self,'last_queue_full_time', 0) > 5: # Log ƒë·ªãnh k·ª≥
                        self.log_activity("‚ö†Ô∏è Queue x·ª≠ l√Ω frame b·ªã ƒë·∫ßy, frame hi·ªán t·∫°i b·ªã b·ªè qua.")
                        setattr(self,'last_queue_full_time', current_time)

        except Exception as e: # B·∫Øt l·ªói chung trong update_frame
             current_time = time.time()
             if not hasattr(self,'last_update_frame_error_time') or current_time - getattr(self,'last_update_frame_error_time', 0) > 5: # Log ƒë·ªãnh k·ª≥
                 self.log_activity(f"‚ùå L·ªói trong qu√° tr√¨nh update_frame: {e}")
                 self.log_activity(traceback.format_exc())
                 setattr(self,'last_update_frame_error_time', current_time)


    def stop_webcam(self):
        if self.cap and self.cap.isOpened():
            self.frame_timer.stop() # D·ª´ng timer ƒë·ªçc frame
            self.cap.release()      # Gi·∫£i ph√≥ng webcam
            self.cap = None
            self.scene.clear()      # X√≥a n·ªôi dung hi·ªÉn th·ªã
            self.pixmap_item = None
            self.graphicsView.setBackgroundBrush(QtGui.QBrush(Qt.darkGray)) # ƒê·∫∑t l·∫°i n·ªÅn x√°m
            self.log_activity("üö´ Webcam ƒë√£ t·∫Øt.")

            # C·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t
            self.ONCam.setEnabled(True); self.OFFCam.setEnabled(False)
            self.SettingButton_ROI_Webcam.setEnabled(False)
            self.CaptureButton_Norm.setEnabled(False)
            self.CaptureButton_Shut.setEnabled(False)
            self.CaptureButton_Fail.setEnabled(False)

            # T·ª± ƒë·ªông d·ª´ng x·ª≠ l√Ω n·∫øu ƒëang ch·∫°y
            if self.processing:
                 self.log_activity("‚ÑπÔ∏è T·ª± ƒë·ªông d·ª´ng x·ª≠ l√Ω do webcam t·∫Øt.")
                 self.toggle_processing() # G·ªçi h√†m toggle ƒë·ªÉ d·ª´ng ƒë√∫ng c√°ch
        elif self.cap is None:
             self.log_activity("‚ÑπÔ∏è Webcam ch∆∞a ƒë∆∞·ª£c b·∫≠t.")
        else: # Tr∆∞·ªùng h·ª£p cap kh√¥ng None nh∆∞ng isOpened() l√† False (l·ªói)
             self.log_activity("‚ÑπÔ∏è Webcam ƒëang ·ªü tr·∫°ng th√°i l·ªói, ƒë√£ d·ªçn d·∫πp.")
             if self.frame_timer.isActive(): self.frame_timer.stop()
             self.cap = None
             if self.scene: self.scene.clear()
             self.pixmap_item = None
             if self.graphicsView: self.graphicsView.setBackgroundBrush(QtGui.QBrush(Qt.darkGray))
             # C·∫≠p nh·∫≠t n√∫t
             if hasattr(self, 'ONCam'): self.ONCam.setEnabled(True)
             if hasattr(self, 'OFFCam'): self.OFFCam.setEnabled(False)
             if hasattr(self, 'SettingButton_ROI_Webcam'): self.SettingButton_ROI_Webcam.setEnabled(False)
             if hasattr(self, 'CaptureButton_Norm'): self.CaptureButton_Norm.setEnabled(False)
             if hasattr(self, 'CaptureButton_Shut'): self.CaptureButton_Shut.setEnabled(False)
             if hasattr(self, 'CaptureButton_Fail'): self.CaptureButton_Fail.setEnabled(False)

             if self.processing:
                  self.log_activity("‚ÑπÔ∏è T·ª± ƒë·ªông d·ª´ng x·ª≠ l√Ω do webcam l·ªói.")
                  self.toggle_processing()

    def load_reference_image(self, img_type):
        if self.processing: QMessageBox.warning(self,"ƒêang X·ª≠ L√Ω","Kh√¥ng th·ªÉ thay ƒë·ªïi ·∫£nh tham chi·∫øu khi ƒëang x·ª≠ l√Ω."); return

        opts=QFileDialog.Options()
        # Th∆∞ m·ª•c g·ª£i √Ω: th∆∞ m·ª•c c·ªßa ·∫£nh c≈© -> th∆∞ m·ª•c l·ªói -> home
        suggested_dir = ""
        old_path = self.config['ref_paths'].get(img_type)
        if old_path and os.path.exists(os.path.dirname(old_path)):
             suggested_dir = os.path.dirname(old_path)
        elif self.error_folder and os.path.exists(self.error_folder):
             suggested_dir = self.error_folder
        else:
             suggested_dir = os.path.expanduser("~")

        fp,_=QFileDialog.getOpenFileName(self,f"Ch·ªçn ·∫£nh tham chi·∫øu cho '{img_type}'",suggested_dir,"Images (*.png *.jpg *.jpeg *.bmp *.jfif *.webp);;All Files (*)",options=opts)

        if fp: # N·∫øu ng∆∞·ªùi d√πng ch·ªçn file
            try:
                img_bytes = np.fromfile(fp, dtype=np.uint8) # ƒê·ªçc an to√†n
                img = cv2.imdecode(img_bytes, cv2.IMREAD_COLOR) # Decode ·∫£nh
                if img is None: raise ValueError("Kh√¥ng th·ªÉ gi·∫£i m√£ file ·∫£nh ho·∫∑c ƒë·ªãnh d·∫°ng kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£.")

                # C·∫≠p nh·∫≠t state v√† config
                self.ref_images[img_type] = img
                self.config['ref_paths'][img_type] = fp
                self.update_button_styles() # C·∫≠p nh·∫≠t UI
                self.log_activity(f"‚úÖ ƒê√£ t·∫£i ·∫£nh '{img_type}' t·ª´ file: {os.path.basename(fp)}")
                self.save_config() # L∆∞u config m·ªõi

            except Exception as e:
                self.log_activity(f"‚ùå L·ªói khi t·∫£i ·∫£nh '{img_type}' t·ª´ file '{fp}': {e}")
                QMessageBox.warning(self,"L·ªói T·∫£i ·∫¢nh",f"Kh√¥ng th·ªÉ t·∫£i ·∫£nh:\n{fp}\n\nL·ªói: {e}")
                # Kh√¥ng thay ƒë·ªïi ·∫£nh/config n·∫øu t·∫£i l·ªói

    def capture_reference_from_webcam(self,img_type):
        if not self.cap or not self.cap.isOpened():
            QMessageBox.warning(self,"Webcam Ch∆∞a B·∫≠t","Vui l√≤ng b·∫≠t webcam tr∆∞·ªõc khi ch·ª•p ·∫£nh."); return
        if self.processing:
            QMessageBox.warning(self,"ƒêang X·ª≠ L√Ω","Kh√¥ng th·ªÉ ch·ª•p ·∫£nh tham chi·∫øu khi ƒëang x·ª≠ l√Ω."); return

        # T·∫°m d·ª´ng timer ƒë·ªÉ l·∫•y frame ·ªïn ƒë·ªãnh (t√πy ch·ªçn)
        was_running = self.frame_timer.isActive()
        if was_running: self.frame_timer.stop(); time.sleep(0.1)

        ret,frame=self.cap.read()

        if was_running and self.cap and self.cap.isOpened(): self.frame_timer.start() # Kh·ªüi ƒë·ªông l·∫°i timer

        if not ret or frame is None:
            QMessageBox.warning(self,"L·ªói ƒê·ªçc Frame","Kh√¥ng th·ªÉ l·∫•y frame t·ª´ webcam ƒë·ªÉ ch·ª•p."); return

        try:
            # Quy·∫øt ƒë·ªãnh l∆∞u frame g·ªëc hay frame ƒë√£ crop ROI?
            # Hi·ªán t·∫°i l∆∞u frame g·ªëc (ch∆∞a crop)
            frame_to_save = frame.copy()
            # N·∫øu mu·ªën l∆∞u frame ƒë√£ crop ROI (n·∫øu ROI t·ªìn t·∫°i):
            # if self.webcam_roi:
            #     x,y,w,h=self.webcam_roi
            #     fh, fw = frame.shape[:2]
            #     x1,y1,x2,y2 = max(0,x),max(0,y),min(fw,x+w),min(fh,y+h)
            #     if x2>x1 and y2>y1: frame_to_save = frame[y1:y2,x1:x2].copy()

            self.ref_images[img_type] = frame_to_save
            self.config['ref_paths'][img_type] = None # ƒê√°nh d·∫•u l√† ·∫£nh t·ª´ webcam
            self.log_activity(f"üì∏ ƒê√£ ch·ª•p ·∫£nh '{img_type}' t·ª´ webcam.")
            self.update_button_styles()
            self.save_config() # L∆∞u config

        except Exception as e:
            self.log_activity(f"‚ùå L·ªói khi l∆∞u ·∫£nh ch·ª•p '{img_type}': {e}")
            QMessageBox.critical(self,"L·ªói Ch·ª•p ·∫¢nh",f"ƒê√£ x·∫£y ra l·ªói khi l∆∞u ·∫£nh ch·ª•p:\n{e}")

    def select_webcam_roi(self):
        if not self.cap or not self.cap.isOpened():
            QMessageBox.warning(self,"Webcam Ch∆∞a B·∫≠t","Vui l√≤ng b·∫≠t webcam tr∆∞·ªõc khi ch·ªçn ROI."); return
        if self.processing:
            QMessageBox.warning(self,"ƒêang X·ª≠ L√Ω","Kh√¥ng th·ªÉ ch·ªçn ROI khi ƒëang x·ª≠ l√Ω."); return

        was_running = self.frame_timer.isActive()
        if was_running: self.frame_timer.stop(); time.sleep(0.1) # D·ª´ng timer, ch·ªù frame ·ªïn ƒë·ªãnh

        ret,frame=self.cap.read()

        # Kh√¥ng kh·ªüi ƒë·ªông l·∫°i timer ngay, ƒë·ªÉ c·ª≠a s·ªï ROI hi·ªÉn th·ªã frame tƒ©nh

        if not ret or frame is None:
            if was_running and self.cap and self.cap.isOpened(): self.frame_timer.start() # B·∫≠t l·∫°i timer n·∫øu l·ªói
            QMessageBox.warning(self,"L·ªói ƒê·ªçc Frame","Kh√¥ng th·ªÉ l·∫•y frame t·ª´ webcam ƒë·ªÉ ch·ªçn ROI."); return

        try:
            window_name="Chon ROI - Keo chuot, roi ENTER/SPACE (C=Huy, R=Reset)"
            cv2.namedWindow(window_name, cv2.WINDOW_NORMAL)
            cv2.resizeWindow(window_name, 800, 600)
            cv2.setWindowTitle(window_name, window_name)

            frame_for_roi = frame.copy()
            # V·∫Ω h∆∞·ªõng d·∫´n
            cv2.putText(frame_for_roi,"Keo chuot de chon vung",(10,30),cv2.FONT_HERSHEY_SIMPLEX,0.7,(0,255,0),2)
            cv2.putText(frame_for_roi,"Nhan ENTER hoac SPACE de xac nhan",(10,60),cv2.FONT_HERSHEY_SIMPLEX,0.7,(0,255,0),2)
            cv2.putText(frame_for_roi,"Nhan C hoac ESC de huy",(10,90),cv2.FONT_HERSHEY_SIMPLEX,0.7,(0,0,255),2)
            cv2.putText(frame_for_roi,"Nhan R de chon lai",(10,120),cv2.FONT_HERSHEY_SIMPLEX,0.7,(255,150,0),2)

            roi = cv2.selectROI(window_name, frame_for_roi, showCrosshair=True, fromCenter=False)
            cv2.destroyWindow(window_name) # ƒê√≥ng c·ª≠a s·ªï ch·ªçn ROI

            # Kh·ªüi ƒë·ªông l·∫°i timer webcam sau khi ƒë√≥ng c·ª≠a s·ªï ROI
            if was_running and self.cap and self.cap.isOpened(): self.frame_timer.start()

            if roi == (0,0,0,0): # Ng∆∞·ªùi d√πng h·ªßy
                self.log_activity("‚ÑπÔ∏è Ng∆∞·ªùi d√πng ƒë√£ h·ªßy ch·ªçn ROI.")
                return

            if roi[2] > 0 and roi[3] > 0: # ROI h·ª£p l·ªá (w>0, h>0)
                self.webcam_roi = tuple(max(0, int(v)) for v in roi) # ƒê·∫£m b·∫£o s·ªë nguy√™n kh√¥ng √¢m
                self.config['webcam_roi'] = list(self.webcam_roi)
                self.log_activity(f"‚úÖ ƒê√£ ch·ªçn ROI m·ªõi: {self.webcam_roi}")
                self.save_config() # L∆∞u ROI m·ªõi
            else:
                self.log_activity("‚ö†Ô∏è ROI ƒë∆∞·ª£c ch·ªçn kh√¥ng h·ª£p l·ªá (chi·ªÅu r·ªông ho·∫∑c chi·ªÅu cao b·∫±ng 0).")

            self.update_button_styles() # C·∫≠p nh·∫≠t UI n√∫t ROI

        except Exception as e:
            self.log_activity(f"‚ùå L·ªói trong qu√° tr√¨nh ch·ªçn ROI: {e}")
            self.log_activity(traceback.format_exc())
            QMessageBox.critical(self,"L·ªói Ch·ªçn ROI",f"ƒê√£ x·∫£y ra l·ªói:\n{e}")
            cv2.destroyAllWindows() # ƒê·∫£m b·∫£o ƒë√≥ng t·∫•t c·∫£ c·ª≠a s·ªï OpenCV n·∫øu l·ªói
            # Kh·ªüi ƒë·ªông l·∫°i timer n·∫øu c·∫ßn
            if was_running and self.cap and self.cap.isOpened() and not self.frame_timer.isActive():
                self.frame_timer.start()


    def select_error_folder(self):
        if self.processing: QMessageBox.warning(self,"ƒêang X·ª≠ L√Ω","Kh√¥ng th·ªÉ thay ƒë·ªïi th∆∞ m·ª•c l·ªói khi ƒëang x·ª≠ l√Ω."); return

        opts=QFileDialog.Options() | QFileDialog.ShowDirsOnly
        suggested_dir = self.error_folder or os.path.expanduser("~")
        folder=QFileDialog.getExistingDirectory(self,"Ch·ªçn th∆∞ m·ª•c l∆∞u ·∫£nh l·ªói, video v√† log",suggested_dir,opts)

        if folder: # N·∫øu ng∆∞·ªùi d√πng ch·ªçn th∆∞ m·ª•c
            # Ki·ªÉm tra quy·ªÅn ghi
            if not os.access(folder,os.W_OK):
                QMessageBox.warning(self,"Kh√¥ng C√≥ Quy·ªÅn Ghi",f"Kh√¥ng th·ªÉ ghi v√†o th∆∞ m·ª•c ƒë√£ ch·ªçn:\n{folder}\n\nVui l√≤ng ch·ªçn th∆∞ m·ª•c kh√°c ho·∫∑c ki·ªÉm tra l·∫°i quy·ªÅn truy c·∫≠p.")
                return # Kh√¥ng thay ƒë·ªïi n·∫øu kh√¥ng ghi ƒë∆∞·ª£c

            # Ch·ªâ c·∫≠p nh·∫≠t n·∫øu th∆∞ m·ª•c th·ª±c s·ª± thay ƒë·ªïi
            if self.error_folder != folder:
                self.error_folder = folder
                self.config['error_folder'] = folder
                self.log_activity(f"üìÅ ƒê√£ ch·ªçn th∆∞ m·ª•c l∆∞u l·ªói: {self.error_folder}")
                # C·∫≠p nh·∫≠t ƒë∆∞·ªùng d·∫´n file log
                self.log_file_path = os.path.join(self.error_folder, LOG_FILE_NAME)
                self.log_activity(f"üìÑ File log s·∫Ω ƒë∆∞·ª£c ghi t·∫°i: {self.log_file_path}")
                # Ghi d√≤ng test v√†o log m·ªõi
                self.log_activity("üìù (ƒê√¢y l√† d√≤ng log th·ª≠ nghi·ªám sau khi ch·ªçn th∆∞ m·ª•c m·ªõi)")
                self.save_config() # L∆∞u config
                self.update_button_styles() # C·∫≠p nh·∫≠t UI n√∫t
            # else: # Th∆∞ m·ª•c kh√¥ng ƒë·ªïi
                # self.log_activity(f"‚ÑπÔ∏è Th∆∞ m·ª•c l·ªói kh√¥ng ƒë·ªïi: {self.error_folder}")


    @QtCore.pyqtSlot()
    def _refresh_com_ports(self):
        if self.serial_enabled: # Kh√¥ng cho refresh khi ƒëang k·∫øt n·ªëi
            self.log_activity("‚ÑπÔ∏è Ng·∫Øt k·∫øt n·ªëi COM tr∆∞·ªõc khi l√†m m·ªõi danh s√°ch.")
            return

        self.comPortComboBox.blockSignals(True) # Ch·∫∑n t√≠n hi·ªáu
        current_selection = self.comPortComboBox.currentText() # L∆∞u l·ª±a ch·ªçn c≈©
        self.comPortComboBox.clear() # X√≥a item c≈©

        port_names = []
        try:
            ports = serial.tools.list_ports.comports()
            port_names = sorted([port.device for port in ports])
            if port_names:
                 self.log_activity(f"üîÑ L√†m m·ªõi COM. T√¨m th·∫•y: {', '.join(port_names)}")
            else:
                 self.log_activity("üîÑ L√†m m·ªõi COM. Kh√¥ng t√¨m th·∫•y c·ªïng n√†o.")
        except Exception as e:
            self.log_activity(f"‚ùå L·ªói khi li·ªát k√™ c√°c c·ªïng COM: {e}")

        # X·ª≠ l√Ω k·∫øt qu·∫£
        if not port_names:
             self.comPortComboBox.addItem("Kh√¥ng t√¨m th·∫•y c·ªïng COM")
             self.comPortComboBox.setEnabled(False)
             self.serial_port_name = None
             # C√°c n√∫t kh√°c s·∫Ω ƒë∆∞·ª£c disable/enable trong update_serial_button_style
        else:
            self.comPortComboBox.addItems(port_names)
            self.comPortComboBox.setEnabled(True)
            # C·ªë g·∫Øng ch·ªçn l·∫°i c·ªïng c≈© ho·∫∑c c·ªïng ƒë·∫ßu ti√™n
            if current_selection in port_names:
                 self.comPortComboBox.setCurrentText(current_selection)
                 self.serial_port_name = current_selection
            else:
                 self.comPortComboBox.setCurrentIndex(0)
                 new_selection = self.comPortComboBox.currentText()
                 self.serial_port_name = new_selection
                 if current_selection and "Kh√¥ng t√¨m th·∫•y" not in current_selection:
                     self.log_activity(f"‚ö†Ô∏è C·ªïng COM '{current_selection}' kh√¥ng c√≤n. ƒê√£ t·ª± ƒë·ªông ch·ªçn '{new_selection}'.")


        self.config['serial_port'] = self.serial_port_name # C·∫≠p nh·∫≠t config
        self.comPortComboBox.blockSignals(False) # B·ªè ch·∫∑n t√≠n hi·ªáu

        # C·∫≠p nh·∫≠t tr·∫°ng th√°i c√°c n√∫t li√™n quan ƒë·∫øn serial
        self.update_serial_button_style()
        self.baudRateComboBox.setEnabled(bool(port_names))


    @QtCore.pyqtSlot()
    def _toggle_serial_port(self):
        if self.processing:
            QMessageBox.warning(self, "ƒêang X·ª≠ L√Ω", "Kh√¥ng th·ªÉ thay ƒë·ªïi tr·∫°ng th√°i k·∫øt n·ªëi COM khi ƒëang x·ª≠ l√Ω.")
            return

        if not self.serial_enabled:
            # --- Logic ƒë·ªÉ B·∫¨T k·∫øt n·ªëi ---
            port = self.comPortComboBox.currentText()
            baud = self.serial_baud_rate

            if not port or "Kh√¥ng t√¨m th·∫•y" in port:
                QMessageBox.warning(self, "Ch∆∞a Ch·ªçn C·ªïng COM", "Vui l√≤ng ch·ªçn m·ªôt c·ªïng COM h·ª£p l·ªá t·ª´ danh s√°ch.")
                return

            # ƒê√≥ng c·ªïng c≈© n·∫øu c√≤n m·ªü (ph√≤ng ng·ª´a)
            if self.serial_port and self.serial_port.is_open:
                try: self.serial_port.close()
                except: pass

            # C·ªë g·∫Øng m·ªü c·ªïng m·ªõi
            try:
                self.log_activity(f"üîå ƒêang c·ªë g·∫Øng k·∫øt n·ªëi c·ªïng {port} @ {baud} baud...")
                # Th√™m write_timeout ƒë·ªÉ tr√°nh b·ªã treo n·∫øu thi·∫øt b·ªã kh√¥ng nh·∫≠n d·ªØ li·ªáu
                self.serial_port = serial.Serial(port, baud, timeout=0.1, write_timeout=1)
                # ---- Th√†nh c√¥ng ----
                self.serial_enabled = True
                self.serial_port_name = port # C·∫≠p nh·∫≠t t√™n c·ªïng th·ª±c t·∫ø ƒë√£ m·ªü
                self.config['serial_enabled'] = True
                self.config['serial_port'] = port
                self.config['serial_baud'] = baud
                self.log_activity(f"‚úÖ ƒê√£ k·∫øt n·ªëi c·ªïng COM: {port} @ {baud} baud")
                # V√¥ hi·ªáu h√≥a c·∫•u h√¨nh
                self.comPortComboBox.setEnabled(False)
                self.baudRateComboBox.setEnabled(False)
                self.refreshComButton.setEnabled(False)

            except serial.SerialException as e:
                # ---- L·ªói khi m·ªü c·ªïng ----
                self.log_activity(f"‚ùå L·ªói khi m·ªü c·ªïng COM '{port}': {e}")
                QMessageBox.critical(self, "L·ªói K·∫øt N·ªëi COM", f"Kh√¥ng th·ªÉ m·ªü c·ªïng {port}.\n\nL·ªói: {e}\n\nKi·ªÉm tra l·∫°i c·ªïng, driver ho·∫∑c thi·∫øt b·ªã c√≥ ƒëang ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi ch∆∞∆°ng tr√¨nh kh√°c kh√¥ng.")
                self.serial_port=None
                self.serial_enabled=False
                self.config['serial_enabled']=False
                # Cho ph√©p c·∫•u h√¨nh l·∫°i
                self.comPortComboBox.setEnabled(True)
                self.baudRateComboBox.setEnabled(True)
                self.refreshComButton.setEnabled(True)

            except Exception as e:
                # ---- L·ªói kh√¥ng x√°c ƒë·ªãnh kh√°c ----
                self.log_activity(f"‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh khi m·ªü c·ªïng COM '{port}': {e}")
                self.log_activity(traceback.format_exc())
                QMessageBox.critical(self, "L·ªói Nghi√™m Tr·ªçng", f"ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën khi k·∫øt n·ªëi c·ªïng COM.\n\nL·ªói: {e}")
                self.serial_port=None
                self.serial_enabled=False
                self.config['serial_enabled']=False
                # Cho ph√©p c·∫•u h√¨nh l·∫°i
                self.comPortComboBox.setEnabled(True)
                self.baudRateComboBox.setEnabled(True)
                self.refreshComButton.setEnabled(True)

        else:
            # --- Logic ƒë·ªÉ T·∫ÆT k·∫øt n·ªëi ---
            port_to_close = self.serial_port_name
            try:
                if self.serial_port and self.serial_port.is_open:
                    self.log_activity(f"üîå ƒêang ng·∫Øt k·∫øt n·ªëi c·ªïng COM: {port_to_close}...")
                    self.serial_port.close()
                    self.log_activity(f"üîå ƒê√£ ng·∫Øt k·∫øt n·ªëi c·ªïng COM: {port_to_close}")
            except serial.SerialException as e:
                 self.log_activity(f"‚ö†Ô∏è L·ªói khi ƒë√≥ng c·ªïng COM '{port_to_close}': {e}")
            except Exception as e:
                 self.log_activity(f"‚ö†Ô∏è L·ªói kh√¥ng x√°c ƒë·ªãnh khi ƒë√≥ng c·ªïng COM '{port_to_close}': {e}")
            finally:
                 # Lu√¥n th·ª±c hi·ªán cleanup v√† c·∫≠p nh·∫≠t UI
                 self.serial_port = None
                 self.serial_enabled = False
                 self.config['serial_enabled'] = False
                 # K√≠ch ho·∫°t l·∫°i c√°c control c·∫•u h√¨nh COM
                 # self._refresh_com_ports() # Kh√¥ng c·∫ßn refresh ngay, ch·ªâ b·∫≠t l·∫°i control
                 has_ports_after_refresh = self.comPortComboBox.count() > 0 and "Kh√¥ng t√¨m th·∫•y" not in self.comPortComboBox.itemText(0)
                 self.comPortComboBox.setEnabled(has_ports_after_refresh)
                 self.baudRateComboBox.setEnabled(has_ports_after_refresh)
                 self.refreshComButton.setEnabled(True)

        # C·∫≠p nh·∫≠t style n√∫t v√† l∆∞u tr·∫°ng th√°i m·ªõi
        self.update_serial_button_style()
        self.save_config()


    @QtCore.pyqtSlot(str)
    def _send_serial_command(self, command):
        if self.serial_enabled and self.serial_port and self.serial_port.is_open:
            try:
                cmd_with_newline = command if command.endswith('\n') else command + '\n'
                byte_command = cmd_with_newline.encode('utf-8')
                bytes_written = self.serial_port.write(byte_command)
                # self.serial_port.flush() # ƒê·∫£m b·∫£o d·ªØ li·ªáu ƒë∆∞·ª£c g·ª≠i ƒëi ngay l·∫≠p t·ª©c (t√πy ch·ªçn)
                if bytes_written == len(byte_command):
                     self.log_activity(f"‚û°Ô∏è G·ª≠i COM [{self.serial_port_name}]: {command}")
                else: # Tr∆∞·ªùng h·ª£p ghi kh√¥ng ƒë·ªß byte (√≠t x·∫£y ra v·ªõi write_timeout)
                     self.log_activity(f"‚ö†Ô∏è G·ª≠i COM [{self.serial_port_name}] kh√¥ng ho√†n ch·ªânh: {command} (Ghi {bytes_written}/{len(byte_command)} bytes)")

            except serial.SerialTimeoutException: # L·ªói timeout khi ghi
                self.log_activity(f"‚ö†Ô∏è Timeout khi ghi l·ªánh COM t·ªõi '{self.serial_port_name}'. Thi·∫øt b·ªã c√≥ th·ªÉ kh√¥ng ph·∫£n h·ªìi.")
                # C√¢n nh·∫Øc t·ª± ƒë·ªông t·∫Øt COM n·∫øu timeout li√™n t·ª•c?
            except serial.SerialException as e: # L·ªói nghi√™m tr·ªçng kh√°c khi ghi
                self.log_activity(f"‚ùå L·ªói nghi√™m tr·ªçng khi ghi l·ªánh COM t·ªõi '{self.serial_port_name}': {e}. T·ª± ƒë·ªông ng·∫Øt k·∫øt n·ªëi.")
                QMessageBox.critical(self,"L·ªói Ghi COM",f"Kh√¥ng th·ªÉ g·ª≠i d·ªØ li·ªáu t·ªõi c·ªïng {self.serial_port_name}.\nK·∫øt n·ªëi s·∫Ω b·ªã ƒë√≥ng.\n\nL·ªói: {e}")
                self._toggle_serial_port() # T·ª± ƒë·ªông g·ªçi h√†m t·∫Øt k·∫øt n·ªëi
            except Exception as e: # L·ªói kh√¥ng x√°c ƒë·ªãnh
                 self.log_activity(f"‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh khi ghi l·ªánh COM: {e}. T·ª± ƒë·ªông ng·∫Øt k·∫øt n·ªëi.")
                 self.log_activity(traceback.format_exc())
                 QMessageBox.critical(self,"L·ªói Ghi COM",f"ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën khi g·ª≠i d·ªØ li·ªáu.\nK·∫øt n·ªëi s·∫Ω b·ªã ƒë√≥ng.\n\nL·ªói: {e}")
                 self._toggle_serial_port() # T·ª± ƒë·ªông g·ªçi h√†m t·∫Øt k·∫øt n·ªëi


    def toggle_processing(self):
        # --- Ki·ªÉm tra ƒëi·ªÅu ki·ªán tr∆∞·ªõc khi B·∫¨T ---
        if not self.processing:
            if not isinstance(self.ref_images.get(REF_NORM),np.ndarray) or self.ref_images[REF_NORM].size == 0:
                 QMessageBox.warning(self,"Thi·∫øu ·∫¢nh Tham Chi·∫øu","Vui l√≤ng t·∫£i ho·∫∑c ch·ª•p ·∫£nh 'Norm' tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu."); return
            if not self.error_folder or not os.path.isdir(self.error_folder) or not os.access(self.error_folder,os.W_OK):
                 QMessageBox.warning(self,"Thi·∫øu Th∆∞ M·ª•c L·ªói","Vui l√≤ng ch·ªçn m·ªôt th∆∞ m·ª•c h·ª£p l·ªá (c√≥ quy·ªÅn ghi) ƒë·ªÉ l∆∞u l·ªói v√† log."); return
            if not self.cap or not self.cap.isOpened():
                 QMessageBox.warning(self,"Webcam Ch∆∞a B·∫≠t","Vui l√≤ng b·∫≠t webcam tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu x·ª≠ l√Ω."); return

        # --- Chuy·ªÉn ƒë·ªïi tr·∫°ng th√°i processing ---
        self.processing = not self.processing

        if self.processing:
            # --- Logic khi B·∫¨T x·ª≠ l√Ω ---
            self.log_activity("‚ñ∂Ô∏è ƒêang chu·∫©n b·ªã b·∫Øt ƒë·∫ßu x·ª≠ l√Ω...")
            # C·∫≠p nh·∫≠t config t·ª´ UI
            self.ssimThresholdSpinBox.blockSignals(True); self.cooldownSpinBox.blockSignals(True); self.runtimeSpinBox.blockSignals(True);
            self._update_threshold_config(self.ssimThresholdSpinBox.value())
            self._update_cooldown_config(self.cooldownSpinBox.value())
            self._update_runtime_config(self.runtimeSpinBox.value())
            self.ssimThresholdSpinBox.blockSignals(False); self.cooldownSpinBox.blockSignals(False); self.runtimeSpinBox.blockSignals(False);
            self.save_config() # L∆∞u config tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu

            # D·ª´ng worker c≈© n·∫øu ƒëang ch·∫°y
            if self.processing_worker.isRunning():
                self.log_activity("‚ö†Ô∏è Worker c≈© ƒëang ch·∫°y, ƒëang c·ªë g·∫Øng d·ª´ng...")
                self.processing_worker.stop(); self.processing_worker.wait(1500)

            # D·ªçn s·∫°ch queue - S·ª¨A L·ªñI SYNTAX
            cleared_count = 0
            while not self.frame_queue.empty():
                try:
                    self.frame_queue.get_nowait()
                    cleared_count += 1
                except Empty:
                    break # Ng·∫Øt v√≤ng l·∫∑p khi queue r·ªóng

            if cleared_count > 0: self.log_activity(f"‚ÑπÔ∏è ƒê√£ d·ªçn {cleared_count} frame c≈© t·ª´ queue.")

            # Kh·ªüi ƒë·ªông worker m·ªõi
            self.processing_worker.last_error_time=0 # Reset cooldown
            self.processing_worker.start()

            self.update_status_label("üîÑ ƒêang x·ª≠ l√Ω...","lightgreen")
            self.log_activity("‚ñ∂Ô∏è B·∫Øt ƒë·∫ßu qu√° tr√¨nh x·ª≠ l√Ω ·∫£nh.")

            # B·∫Øt ƒë·∫ßu h·∫πn gi·ªù runtime n·∫øu c·∫ßn
            if self._current_runtime_minutes > 0:
                duration_ms = self._current_runtime_minutes * 60 * 1000
                self.runtime_timer.start(duration_ms)
                self.log_activity(f"‚è±Ô∏è Qu√° tr√¨nh x·ª≠ l√Ω s·∫Ω t·ª± ƒë·ªông d·ª´ng sau {self._current_runtime_minutes} ph√∫t.")
            else:
                 if self.runtime_timer.isActive(): self.runtime_timer.stop()

            # Reset tr·∫°ng th√°i ghi video
            self.video_writer,self.current_video_path,self.error_occurred_during_recording = None,None,False

            # V√¥ hi·ªáu h√≥a c√°c n√∫t c√†i ƒë·∫∑t
            self.disable_settings_while_processing(True)
        else:
            # --- Logic khi T·∫ÆT x·ª≠ l√Ω ---
            self.log_activity("‚èπ ƒêang d·ª´ng qu√° tr√¨nh x·ª≠ l√Ω...")
            # D·ª´ng worker thread
            if self.processing_worker.isRunning():
                self.processing_worker.stop()
                # Ch·ªù worker d·ª´ng m·ªôt ch√∫t ƒë·ªÉ x·ª≠ l√Ω n·ªët frame cu·ªëi c√πng? (T√πy ch·ªçn)
                # self.processing_worker.wait(500)

            # D·ª´ng runtime timer
            if self.runtime_timer.isActive():
                self.runtime_timer.stop(); self.log_activity("‚è±Ô∏è ƒê√£ h·ªßy h·∫πn gi·ªù d·ª´ng t·ª± ƒë·ªông.")

            # X·ª≠ l√Ω d·ª´ng ghi video
            if self.video_writer is not None:
                video_path_to_check = self.current_video_path
                try:
                    self.video_writer.release(); self.log_activity("‚ö™Ô∏è ƒê√£ d·ª´ng ghi video.")
                    if video_path_to_check and os.path.exists(video_path_to_check):
                        if not self.error_occurred_during_recording:
                             try: os.remove(video_path_to_check); self.log_activity(f"üóëÔ∏è ƒê√£ x√≥a file video kh√¥ng c√≥ l·ªói: {os.path.basename(video_path_to_check)}")
                             except Exception as e: self.log_activity(f"‚ö†Ô∏è L·ªói khi x√≥a file video '{os.path.basename(video_path_to_check)}': {e}")
                        else: self.log_activity(f"üíæ ƒê√£ l∆∞u file video c√≥ l·ªói: {os.path.basename(video_path_to_check)}")
                except Exception as e: self.log_activity(f"‚ùå L·ªói khi d·ª´ng VideoWriter: {e}")
                finally: self.video_writer, self.current_video_path, self.error_occurred_during_recording = None, None, False

            # C·∫≠p nh·∫≠t UI
            self.update_status_label("‚èπ ƒê√£ d·ª´ng x·ª≠ l√Ω","orange")
            self.log_activity("‚èπ Qu√° tr√¨nh x·ª≠ l√Ω ·∫£nh ƒë√£ d·ª´ng.")
            self.ssim_label.setText("SSIM: N/A") # Reset SSIM
            # K√≠ch ho·∫°t l·∫°i c√°c n√∫t c√†i ƒë·∫∑t
            self.disable_settings_while_processing(False)

        # C·∫≠p nh·∫≠t text/style n√∫t Start/Stop
        self.update_toggle_button_text()


    @QtCore.pyqtSlot()
    def _mark_error_occurred(self):
        # Ch·ªâ log l·∫ßn ƒë·∫ßu ti√™n c√≥ l·ªói trong phi√™n ghi video hi·ªán t·∫°i
        if self._record_on_error_enabled and not self.error_occurred_during_recording:
            self.log_activity("‚ùó Ph√°t hi·ªán l·ªói ƒë·∫ßu ti√™n trong phi√™n ghi. Video s·∫Ω ƒë∆∞·ª£c l∆∞u khi d·ª´ng.")
        self.error_occurred_during_recording=True

    def disable_settings_while_processing(self, disable):
        # N√∫t t·∫£i/ch·ª•p ·∫£nh tham chi·∫øu
        self.SettingButton_Norm.setEnabled(not disable)
        self.SettingButton_Shutdown.setEnabled(not disable)
        self.SettingButton_Fail.setEnabled(not disable)

        webcam_is_on = self.cap is not None and self.cap.isOpened()
        self.CaptureButton_Norm.setEnabled(webcam_is_on and not disable)
        self.CaptureButton_Shut.setEnabled(webcam_is_on and not disable)
        self.CaptureButton_Fail.setEnabled(webcam_is_on and not disable)
        self.SettingButton_ROI_Webcam.setEnabled(webcam_is_on and not disable)

        # N√∫t c·∫•u h√¨nh chung
        self.SaveButton.setEnabled(not disable)
        self.ssimThresholdSpinBox.setEnabled(not disable)
        self.cooldownSpinBox.setEnabled(not disable)
        self.runtimeSpinBox.setEnabled(not disable)
        self.ToggleRecordOnErrorButton.setEnabled(not disable)

        # N√∫t c·∫•u h√¨nh Serial
        can_configure_serial = not disable and not self.serial_enabled
        has_ports = self.comPortComboBox.count() > 0 and "Kh√¥ng t√¨m th·∫•y" not in self.comPortComboBox.itemText(0)
        self.comPortComboBox.setEnabled(can_configure_serial and has_ports)
        self.baudRateComboBox.setEnabled(can_configure_serial and has_ports)
        # N√∫t refresh lu√¥n b·∫≠t tr·ª´ khi ƒëang k·∫øt n·ªëi serial
        self.refreshComButton.setEnabled(not self.serial_enabled)

        # N√∫t b·∫≠t/t·∫Øt Serial (ch·ªâ enable khi kh√¥ng x·ª≠ l√Ω *v√†* c√≥ c·ªïng)
        self.ToggleSerialPortButton.setEnabled(not disable and has_ports)

        # N√∫t b·∫≠t/t·∫Øt Webcam (ch·ªâ enable khi kh√¥ng x·ª≠ l√Ω)
        self.ONCam.setEnabled(not disable and not webcam_is_on)
        self.OFFCam.setEnabled(not disable and webcam_is_on)


    @QtCore.pyqtSlot()
    def _runtime_timer_timeout(self):
        self.log_activity(f"‚è±Ô∏è ƒê√£ h·∫øt th·ªùi gian ch·∫°y t·ªëi ƒëa ({self._current_runtime_minutes} ph√∫t).")
        QMessageBox.information(self,"H·∫øt Gi·ªù",f"Qu√° tr√¨nh x·ª≠ l√Ω ƒë√£ ch·∫°y ƒë·ªß {self._current_runtime_minutes} ph√∫t v√† s·∫Ω t·ª± ƒë·ªông tho√°t.")
        # T·ª± ƒë·ªông d·ª´ng x·ª≠ l√Ω tr∆∞·ªõc khi ƒë√≥ng
        if self.processing:
             self.toggle_processing() # G·ªçi h√†m d·ª´ng chu·∫©n
        # Sau ƒë√≥ ƒë√≥ng ·ª©ng d·ª•ng
        self.close_application() # G·ªçi h√†m ƒë√≥ng chu·∫©n


    def compare_images(self, img1, img2, threshold):
        # --- Ki·ªÉm tra ƒë·∫ßu v√†o ---
        if img1 is None or not isinstance(img1, np.ndarray) or img1.size==0:
             # self.log_activity("L·ªói compare: img1 kh√¥ng h·ª£p l·ªá.", level="error") # N√™n d√πng signal log
             return False, None
        if img2 is None or not isinstance(img2, np.ndarray) or img2.size==0:
             # self.log_activity("L·ªói compare: img2 kh√¥ng h·ª£p l·ªá.", level="warning") # ·∫¢nh ref c√≥ th·ªÉ ch∆∞a load
             return False, None

        try:
            # --- Chuy·ªÉn sang grayscale ---
            img1_gray = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY) if len(img1.shape)>2 else img1
            img2_gray = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY) if len(img2.shape)>2 else img2

            # --- Resize n·∫øu k√≠ch th∆∞·ªõc kh√°c nhau ---
            if img1_gray.shape != img2_gray.shape:
                h1, w1 = img1_gray.shape
                h2, w2 = img2_gray.shape
                interpolation = cv2.INTER_AREA if (w2 > w1 or h2 > h1) else cv2.INTER_LINEAR
                try:
                    img2_resized = cv2.resize(img2_gray, (w1, h1), interpolation=interpolation)
                    if img2_resized is None or img2_resized.shape != (h1, w1): raise ValueError("Resize failed")
                    img2_gray = img2_resized
                    # Log ƒë·ªãnh k·ª≥ n·∫øu ph·∫£i resize
                    ct = time.time();
                    if not hasattr(self,'lrt') or ct-getattr(self,'lrt',0)>15:
                        # D√πng signal ƒë·ªÉ log t·ª´ h√†m n√†y (an to√†n h∆°n)
                        if hasattr(self, 'log_signal') and isinstance(self.log_signal, pyqtSignal):
                            self.log_signal.emit(f"‚ÑπÔ∏è Resize ·∫£nh ref ({w2}x{h2})->({w1}x{h1}) ƒë·ªÉ so s√°nh SSIM.")
                        setattr(self,'lrt',ct)
                except Exception as resize_err:
                    ct = time.time();
                    if not hasattr(self,'lre') or ct-getattr(self,'lre',0)>10:
                        if hasattr(self, 'log_signal') and isinstance(self.log_signal, pyqtSignal):
                            self.log_signal.emit(f"‚ùå L·ªói resize ref {w2}x{h2}->{w1}x{h1}: {resize_err}")
                        setattr(self,'lre',ct)
                    return False,None # Kh√¥ng th·ªÉ so s√°nh n·∫øu resize l·ªói
            else: # K√≠ch th∆∞·ªõc kh·ªõp, x√≥a log resize n·∫øu c√≥
                 if hasattr(self,'lrt'): delattr(self,'lrt')
                 if hasattr(self,'lre'): delattr(self,'lre')

            # --- T√≠nh SSIM ---
            h, w = img1_gray.shape
            win_size = min(min(h, w), 7); # Gi·ªõi h·∫°n max 7x7
            if win_size % 2 == 0: win_size -= 1; win_size = max(3, win_size) # ƒê·∫£m b·∫£o l·∫ª >= 3

            if h < win_size or w < win_size: # Ki·ªÉm tra ·∫£nh c√≥ ƒë·ªß l·ªõn kh√¥ng
                ct = time.time();
                if not hasattr(self,'lsie') or ct-getattr(self,'lsie',0)>10:
                    if hasattr(self, 'log_signal') and isinstance(self.log_signal, pyqtSignal):
                        self.log_signal.emit(f"‚ö†Ô∏è ·∫¢nh/ROI ({w}x{h}) qu√° nh·ªè cho SSIM (win={win_size}).")
                    setattr(self,'lsie',ct)
                return False,None
            else: # K√≠ch th∆∞·ªõc OK, x√≥a log l·ªói n·∫øu c√≥
                 if hasattr(self,'lsie'): delattr(self,'lsie')

            # G·ªçi h√†m SSIM ƒë√£ t·ªëi ∆∞u (t·ª± vi·∫øt ho·∫∑c t·ª´ th∆∞ vi·ªán)
            # S·ª≠ d·ª•ng h√†m ssim_opencv ƒë√£ c√≥ ·ªü tr√™n
            score = ssim_opencv(img1_gray.astype(np.float64), img2_gray.astype(np.float64), win_size=win_size, data_range=255.0)

            if score is None or not np.isfinite(score): # Ki·ªÉm tra k·∫øt qu·∫£ SSIM
                 ct = time.time();
                 if not hasattr(self,'lssime') or ct-getattr(self,'lssime',0)>10:
                    if hasattr(self, 'log_signal') and isinstance(self.log_signal, pyqtSignal):
                        self.log_signal.emit("‚ö†Ô∏è T√≠nh to√°n SSIM tr·∫£ v·ªÅ gi√° tr·ªã kh√¥ng h·ª£p l·ªá (None, NaN, Inf).")
                    setattr(self,'lssime',ct)
                 return False, None
            else: # C√≥ score h·ª£p l·ªá, x√≥a log l·ªói n·∫øu c√≥
                 if hasattr(self,'lssime'): delattr(self,'lssime')

            return score >= threshold, score # Tr·∫£ v·ªÅ k·∫øt qu·∫£ so s√°nh v√† ƒëi·ªÉm s·ªë

        except cv2.error as cv_err:
            ct=time.time();
            if not hasattr(self,'lcve') or ct-getattr(self,'lcve',0)>5:
                if hasattr(self, 'log_signal') and isinstance(self.log_signal, pyqtSignal):
                    self.log_signal.emit(f"‚ùå L·ªói OpenCV compare: {cv_err.msg}")
                setattr(self,'lcve',ct);
            return False,None
        except Exception as e:
            ct=time.time();
            if not hasattr(self,'lce') or ct-getattr(self,'lce',0)>5:
                if hasattr(self, 'log_signal') and isinstance(self.log_signal, pyqtSignal):
                    self.log_signal.emit(f"‚ùå L·ªói compare: {e}")
                    # self.log_signal.emit(traceback.format_exc()) # Avoid long tracebacks in worker log
                setattr(self,'lce',ct);
            return False,None


    @QtCore.pyqtSlot(np.ndarray, str)
    def save_error_image_from_thread(self, frame_copy, file_path):
        # H√†m n√†y ƒë∆∞·ª£c g·ªçi b·ªüi t√≠n hi·ªáu t·ª´ worker, ch·∫°y tr√™n Main thread
        try:
            # T·∫°o th∆∞ m·ª•c n·∫øu ch∆∞a c√≥ (an to√†n h∆°n khi l√†m ·ªü Main thread)
            save_dir = os.path.dirname(file_path)
            if not os.path.exists(save_dir):
                 os.makedirs(save_dir, exist_ok=True)

            # Encode v√† ghi file (c√≥ th·ªÉ v·∫´n m·∫•t ch√∫t th·ªùi gian)
            success, img_encoded = cv2.imencode('.png', frame_copy, [cv2.IMWRITE_PNG_COMPRESSION, 3])
            if not success or img_encoded is None: raise ValueError("imencode failed.")

            with open(file_path, "wb") as f: f.write(img_encoded.tobytes())
            self.log_activity(f"üíæ ƒê√£ l∆∞u ·∫£nh l·ªói: {os.path.basename(file_path)}")

        except Exception as e:
            self.log_activity(f"‚ùå L·ªói khi l∆∞u ·∫£nh l·ªói '{os.path.basename(file_path)}' tr√™n lu·ªìng ch√≠nh: {e}")
            self.log_activity(traceback.format_exc())


    def close_application(self):
        self.log_activity("üö™ ƒêang y√™u c·∫ßu ƒë√≥ng ·ª©ng d·ª•ng...")
        self.close() # K√≠ch ho·∫°t closeEvent


    def closeEvent(self, event):
        self.log_activity("üö™ B·∫Øt ƒë·∫ßu qu√° tr√¨nh d·ªçn d·∫πp tr∆∞·ªõc khi ƒë√≥ng...")

        # D·ª´ng c√°c timer
        if self.runtime_timer.isActive(): self.runtime_timer.stop()
        if self.frame_timer.isActive(): self.frame_timer.stop()

        # D·ª´ng lu·ªìng x·ª≠ l√Ω
        worker_stopped = True
        if self.processing or self.processing_worker.isRunning():
            if self.processing_worker.isRunning():
                self.log_activity("‚öôÔ∏è ƒêang d·ª´ng lu·ªìng x·ª≠ l√Ω...")
                self.processing_worker.stop()
                if not self.processing_worker.wait(2000): # Ch·ªù t·ªëi ƒëa 2 gi√¢y
                    self.log_activity("‚ö†Ô∏è Lu·ªìng x·ª≠ l√Ω kh√¥ng d·ª´ng k·ªãp th·ªùi!")
                    worker_stopped = False
                else:
                    self.log_activity("‚úÖ Lu·ªìng x·ª≠ l√Ω ƒë√£ d·ª´ng.")
            self.processing = False

        # Gi·∫£i ph√≥ng webcam
        if self.cap and self.cap.isOpened():
            self.cap.release(); self.cap = None; self.log_activity("üö´ Webcam ƒë√£ ƒë∆∞·ª£c gi·∫£i ph√≥ng.")

        # Gi·∫£i ph√≥ng video writer v√† x·ª≠ l√Ω file cu·ªëi
        if self.video_writer is not None:
            vp=self.current_video_path;
            try:
                self.video_writer.release(); self.log_activity("‚ö™Ô∏è Video writer ƒë√£ ƒë∆∞·ª£c gi·∫£i ph√≥ng.")
                if vp and os.path.exists(vp):
                    if not self.error_occurred_during_recording:
                        try: os.remove(vp); self.log_activity(f"üóëÔ∏è ƒê√£ x√≥a video cu·ªëi (kh√¥ng l·ªói): {os.path.basename(vp)}")
                        except Exception as e: self.log_activity(f"‚ö†Ô∏è L·ªói x√≥a video '{os.path.basename(vp)}': {e}")
                    else: self.log_activity(f"üíæ ƒê√£ l∆∞u video cu·ªëi (c√≥ l·ªói): {os.path.basename(vp)}")
            except Exception as e: self.log_activity(f"‚ùå L·ªói gi·∫£i ph√≥ng VideoWriter: {e}")
            finally: self.video_writer, self.current_video_path = None, None

        # ƒê√≥ng c·ªïng Serial
        if self.serial_port and self.serial_port.is_open:
            port_name = self.serial_port_name
            try:
                self.serial_port.close(); self.log_activity(f"üîå ƒê√£ ƒë√≥ng c·ªïng COM: {port_name}")
            except Exception as e: self.log_activity(f"‚ö†Ô∏è L·ªói ƒë√≥ng COM {port_name}: {e}")
            finally: self.serial_port = None; self.serial_enabled = False

        # D·ªçn queue l·∫ßn cu·ªëi - S·ª¨A L·ªñI SYNTAX
        qs=self.frame_queue.qsize();
        if qs>0: self.log_activity(f"‚ÑπÔ∏è ƒêang d·ªçn {qs} frame c√≤n l·∫°i trong queue...")
        while not self.frame_queue.empty():
            try:
                self.frame_queue.get_nowait()
            except Empty:
                break # Ng·∫Øt v√≤ng l·∫∑p khi queue r·ªóng

        # L∆∞u c·∫•u h√¨nh l·∫ßn cu·ªëi
        self.log_activity("üíæ ƒêang l∆∞u c·∫•u h√¨nh cu·ªëi c√πng...")
        self.save_config()

        self.log_activity("üö™ D·ªçn d·∫πp ho√†n t·∫•t. ·ª®ng d·ª•ng s·∫Ω ƒë√≥ng.")

        # Ghi d√≤ng cu·ªëi v√†o file log
        if self.log_file_path:
             try:
                 ld=os.path.dirname(self.log_file_path);
                 if ld and not os.path.exists(ld): os.makedirs(ld,exist_ok=True)
                 with open(self.log_file_path,"a",encoding="utf-8") as lf: lf.write(f"---\n{time.strftime('%Y-%m-%d %H:%M:%S')} - ·ª®ng d·ª•ng ƒë√£ ƒë√≥ng\n---\n")
             except Exception as e: print(f"L·ªói ghi log cu·ªëi: {e}") # In ra console n·∫øu kh√¥ng ghi ƒë∆∞·ª£c

        event.accept() # Ch·∫•p nh·∫≠n s·ª± ki·ªán ƒë√≥ng

# --- Main Execution ---
if __name__ == "__main__":
    # B·∫≠t c√†i ƒë·∫∑t HiDPI n·∫øu c√≥
    if hasattr(QtCore.Qt,'AA_EnableHighDpiScaling'): QtWidgets.QApplication.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling,True)
    if hasattr(QtCore.Qt,'AA_UseHighDpiPixmaps'): QtWidgets.QApplication.setAttribute(QtCore.Qt.AA_UseHighDpiPixmaps,True)

    app=QtWidgets.QApplication(sys.argv)
    window=ImageCheckerApp()
    window.show()
    sys.exit(app.exec_())