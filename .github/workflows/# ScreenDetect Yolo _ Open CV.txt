# ScreenDetect Yolo _ Open CV
# -*- coding: utf-8 -*-
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import (QFileDialog, QLabel, QGraphicsView, QGraphicsScene,
                             QMessageBox, QWidget, QTextEdit,
                             QSpinBox, QDoubleSpinBox, QComboBox, QPushButton,
                             QSizePolicy, QGroupBox)
from PyQt5.QtCore import Qt, QThread, pyqtSignal, QTimer
import cv2
import numpy as np
import sys
import os
import time
import json
from queue import Queue, Empty
import traceback
import serial
import serial.tools.list_ports
from enum import Enum, auto

# --- Th·ª≠ import YOLOv8 ---
try:
    from ultralytics import YOLO
    YOLO_AVAILABLE = True
except ImportError:
    YOLO = None
    YOLO_AVAILABLE = False
    # In c·∫£nh b√°o ra console m·ªôt l·∫ßn khi kh·ªüi ƒë·ªông
    print("WARNING: Th∆∞ vi·ªán 'ultralytics' (YOLOv8) ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t. Ch·ª©c nƒÉng YOLO s·∫Ω b·ªã v√¥ hi·ªáu h√≥a.")
    print("         Vui l√≤ng c√†i ƒë·∫∑t b·∫±ng l·ªánh: pip install ultralytics")

# --- H·∫±ng s·ªë ---
METHOD_SSIM = "OpenCV SSIM"
METHOD_YOLO = "YOLOv8 Detection"

class ComparisonStatus(Enum):
    NORMAL = auto()
    SHUTDOWN = auto()
    FAIL = auto()
    UNKNOWN = auto()
    ERROR = auto()

STATUS_MAP = {
    ComparisonStatus.NORMAL: {"label": "Normal", "color": "lightgreen", "log_prefix": "‚úÖ", "serial": "Norm"},
    ComparisonStatus.SHUTDOWN: {"label": "Shutdown", "color": "lightblue", "log_prefix": "‚ÑπÔ∏è", "serial": "Shutdown"},
    ComparisonStatus.FAIL: {"label": "FAIL!", "color": "red", "log_prefix": "‚ùå", "serial": "Fail"},
    ComparisonStatus.UNKNOWN: {"label": "Unknown Mismatch", "color": "orange", "log_prefix": "‚ö†Ô∏è", "serial": None},
    ComparisonStatus.ERROR: {"label": "Comparison Error", "color": "magenta", "log_prefix": "üí•", "serial": None},
}

REF_NORM = "Norm"
REF_SHUTDOWN = "Shutdown"
REF_FAIL = "Fail"
DEFAULT_SSIM_THRESHOLD = 0.90
DEFAULT_ERROR_COOLDOWN = 15
DEFAULT_RUNTIME_MINUTES = 0
DEFAULT_RECORD_ON_ERROR = False
DEFAULT_SERIAL_ENABLED = False
DEFAULT_BAUD_RATE = 9600
CONFIG_FILE_NAME = "image_checker_config.json"
LOG_FILE_NAME = "activity_log.txt"
VIDEO_SUBFOLDER = "error_videos"
COMMON_BAUD_RATES = [9600, 19200, 38400, 57600, 115200]
DEFAULT_COMPARISON_METHOD = METHOD_SSIM
DEFAULT_YOLO_CONFIDENCE = 0.5

# --- H√†m SSIM ---
def ssim_opencv(img1, img2, K1=0.01, K2=0.03, win_size=7, data_range=255.0):
    if img1 is None or img2 is None: return None
    try:
        if len(img1.shape) > 2: img1 = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)
        if len(img2.shape) > 2: img2 = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)

        if img1.shape != img2.shape:
            h1, w1 = img1.shape[:2]
            h2, w2 = img2.shape[:2]
            interpolation = cv2.INTER_AREA if (w2 > w1 or h2 > h1) else cv2.INTER_LINEAR
            img2 = cv2.resize(img2, (w1, h1), interpolation=interpolation)
            if img2 is None or img2.shape != (h1, w1):
                print("Warning: SSIM resize failed")
                return None

        h, w = img1.shape
        win_size = min(win_size, h, w)
        if win_size % 2 == 0: win_size -= 1
        win_size = max(3, win_size)
        if h < win_size or w < win_size: return None

        if img1.dtype != np.float64: img1 = img1.astype(np.float64)
        if img2.dtype != np.float64: img2 = img2.astype(np.float64)

        C1 = (K1 * data_range)**2
        C2 = (K2 * data_range)**2
        sigma = 1.5
        mu1 = cv2.GaussianBlur(img1, (win_size, win_size), sigma)
        mu2 = cv2.GaussianBlur(img2, (win_size, win_size), sigma)
        mu1_sq = mu1 * mu1
        mu2_sq = mu2 * mu2
        mu1_mu2 = mu1 * mu2
        sigma1_sq = cv2.GaussianBlur(img1 * img1, (win_size, win_size), sigma) - mu1_sq
        sigma2_sq = cv2.GaussianBlur(img2 * img2, (win_size, win_size), sigma) - mu2_sq
        sigma12 = cv2.GaussianBlur(img1 * img2, (win_size, win_size), sigma) - mu1_mu2
        numerator = (2 * mu1_mu2 + C1) * (2 * sigma12 + C2)
        denominator = (mu1_sq + mu2_sq + C1) * (sigma1_sq + sigma2_sq + C2)
        ssim_map = numerator / (denominator + 1e-8)
        ssim_map = np.clip(ssim_map, 0, 1)
        mssim = np.mean(ssim_map)
        if not np.isfinite(mssim): return None
        return mssim

    except cv2.error as cv_err:
        print(f"OpenCV Error in SSIM: {cv_err}")
        return None
    except Exception as e:
        print(f"General Error in SSIM: {e}")
        traceback.print_exc()
        return None

# --- Worker Thread ---
# ... (ProcessingWorker class gi·ªØ nguy√™n nh∆∞ tr∆∞·ªõc - kh√¥ng c√≥ l·ªói c√∫ ph√°p r√µ r√†ng) ...
class ProcessingWorker(QThread):
    log_signal = pyqtSignal(str)
    status_signal = pyqtSignal(ComparisonStatus, object)
    save_error_signal = pyqtSignal(np.ndarray, str)
    comparison_details_signal = pyqtSignal(dict)
    error_detected_signal = pyqtSignal()
    serial_command_signal = pyqtSignal(str)

    def __init__(self, frame_queue, ref_data_provider, config_provider, compare_function):
        super().__init__()
        self.frame_queue = frame_queue
        self.get_ref_data = ref_data_provider
        self.get_config = config_provider
        self.compare_images_func = compare_function
        self.running = False
        self.last_error_time = 0
        self.last_emitted_serial_state = None
        self.last_status = None

    def run(self):
        self.running = True
        self.log_signal.emit("‚öôÔ∏è Worker started.")
        last_status_log_time = 0
        error_signaled_this_session = False
        self.last_emitted_serial_state = None
        self.last_status = None

        while self.running:
            try:
                frame = self.frame_queue.get(timeout=0.5)
            except Empty:
                if not self.running: break
                continue
            except Exception as e:
                self.log_signal.emit(f"‚ùå Error getting frame from queue: {e}")
                continue

            if not self.running: break

            try:
                cfg = self.get_config()
                err_cd = cfg.get('error_cooldown', DEFAULT_ERROR_COOLDOWN)
                err_f = cfg.get('error_folder')
                ref_data = self.get_ref_data()

                current_status, details = self.compare_images_func(frame, ref_data, cfg)
                self.comparison_details_signal.emit(details or {})

                status_info = STATUS_MAP.get(current_status, STATUS_MAP[ComparisonStatus.ERROR])
                status_label = status_info["label"]
                status_color = status_info["color"]
                log_prefix = status_info["log_prefix"]
                serial_cmd = status_info["serial"]

                log_msg = f"{log_prefix} Status: {status_label}"
                detail_str = ""
                if details:
                    if 'detected' in details:
                        det_items = sorted([f"{k}:{v}" for k,v in details['detected'].items()])
                        detail_str = f"Detect: {', '.join(det_items) if det_items else 'None'}"
                        if 'count' in details: detail_str += f" (Total: {details['count']})"
                    elif 'ssim_norm' in details:
                        detail_str = f"SSIM: {details['ssim_norm']:.4f}"
                    if 'reason' in details: detail_str += f" (Reason: {details['reason']})"
                    elif 'error' in details: detail_str += f" (Error: {details['error']})"
                    if detail_str: log_msg += f" ({detail_str})"

                needs_logging = True
                current_time_log = time.time()
                if current_status == ComparisonStatus.NORMAL:
                    if current_time_log - last_status_log_time < 5.0: needs_logging = False
                    else: last_status_log_time = current_time_log
                else:
                    last_status_log_time = 0
                    if self.last_status == current_status: needs_logging = False

                if needs_logging: self.log_signal.emit(log_msg)

                if self.last_status != current_status:
                    self.status_signal.emit(current_status, details or {})
                    self.last_status = current_status

                is_problem_state = current_status in [ComparisonStatus.FAIL, ComparisonStatus.UNKNOWN, ComparisonStatus.ERROR]
                should_save_img = is_problem_state
                should_record = is_problem_state

                if should_record and not error_signaled_this_session:
                    self.error_detected_signal.emit()
                    error_signaled_this_session = True

                if serial_cmd and self.last_emitted_serial_state != serial_cmd:
                    self.serial_command_signal.emit(serial_cmd)
                    self.last_emitted_serial_state = serial_cmd
                elif not serial_cmd and self.last_emitted_serial_state:
                    self.last_emitted_serial_state = None

                current_time_save = time.time()
                if should_save_img and err_f and (current_time_save - self.last_error_time > err_cd):
                    try:
                        err_sub = status_label.lower().replace("!", "").replace(" ", "_").replace(":", "")
                        save_folder = os.path.join(err_f, err_sub)
                        os.makedirs(save_folder, exist_ok=True)
                        timestamp = time.strftime('%Y%m%d_%H%M%S') + f"_{int((current_time_save - int(current_time_save)) * 1000):03d}"
                        filename = f"{err_sub}_{timestamp}.png"
                        filepath = os.path.join(save_folder, filename)
                        self.save_error_signal.emit(frame.copy(), filepath)
                        self.last_error_time = current_time_save
                    except Exception as e:
                        self.log_signal.emit(f"‚ùå L·ªói khi chu·∫©n b·ªã l∆∞u ·∫£nh l·ªói: {e}")
                elif not err_f and should_save_img:
                    pass

                sleep_time = 0.05 if current_status == ComparisonStatus.NORMAL else 0.1
                time.sleep(sleep_time)

            except Exception as e:
                self.log_signal.emit(f"üí• L·ªói nghi√™m tr·ªçng trong worker logic: {e}")
                self.log_signal.emit(traceback.format_exc())
                try:
                    self.status_signal.emit(ComparisonStatus.ERROR, {"error": str(e)})
                except Exception as sig_e:
                    print(f"CRITICAL: Failed to emit error status signal: {sig_e}")
                self.last_status = ComparisonStatus.ERROR
                time.sleep(0.5)

        self.log_signal.emit("‚öôÔ∏è Worker finished.")
        self.last_emitted_serial_state = None
        error_signaled_this_session = False
        self.last_status = None

    def stop(self):
        self.running = False
        self.log_signal.emit("‚öôÔ∏è ƒêang y√™u c·∫ßu d·ª´ng worker...")

# --- Main Application Window ---
class ImageCheckerApp(QtWidgets.QMainWindow):
    # --- __init__ v√† c√°c h√†m provider gi·ªØ nguy√™n ---
    def __init__(self):
        super().__init__()
        # --- State Variables ---
        self.cap = None
        self.webcam_fps = 15.0
        self.frame_timer = QTimer(self)
        self.ref_data = {k: None for k in [REF_NORM, REF_SHUTDOWN, REF_FAIL]}
        self.yolo_model = None
        self.webcam_roi = None
        self.processing = False
        self.error_folder = None
        self.log_file_path = None
        self.pixmap_item = None
        self.runtime_timer = QTimer(self)
        self._current_runtime_minutes = DEFAULT_RUNTIME_MINUTES
        self._current_ssim_threshold = DEFAULT_SSIM_THRESHOLD
        self._current_error_cooldown = DEFAULT_ERROR_COOLDOWN
        self._record_on_error_enabled = DEFAULT_RECORD_ON_ERROR
        self.video_writer = None
        self.current_video_path = None
        self.error_occurred_during_recording = False
        self.serial_port = None
        self.serial_port_name = None
        self.serial_baud_rate = DEFAULT_BAUD_RATE
        self.serial_enabled = DEFAULT_SERIAL_ENABLED
        self.current_comparison_method = DEFAULT_COMPARISON_METHOD

        self.comparison_functions = {
            METHOD_SSIM: self.compare_ssim_strategy,
            METHOD_YOLO: self.compare_yolo_strategy,
        }

        self.config = {
            'comparison_method': self.current_comparison_method,
            'ssim_threshold': self._current_ssim_threshold,
            'error_cooldown': self._current_error_cooldown,
            'runtime_duration_minutes': self._current_runtime_minutes,
            'record_on_error': self._record_on_error_enabled,
            'error_folder': None,
            'ref_paths': {k: None for k in [REF_NORM, REF_SHUTDOWN, REF_FAIL]},
            'webcam_roi': None,
            'serial_port': self.serial_port_name,
            'serial_baud': self.serial_baud_rate,
            'serial_enabled': self.serial_enabled,
            'yolo_model_path': None,
            'yolo_confidence': DEFAULT_YOLO_CONFIDENCE,
        }

        self.frame_timer.timeout.connect(self.update_frame)
        self.runtime_timer.setSingleShot(True)
        self.runtime_timer.timeout.connect(self._runtime_timer_timeout)
        self.frame_queue = Queue(maxsize=10)
        self.processing_worker = None

        self.init_ui()
        self.load_config()
        self._refresh_com_ports()
        self.log_activity("·ª®ng d·ª•ng kh·ªüi ƒë·ªông.")
        self.update_all_ui_elements()
        if self.current_comparison_method == METHOD_YOLO and self.config.get('yolo_model_path'):
            QTimer.singleShot(150, self._load_yolo_model)

    def get_current_config_for_worker(self):
        return {
            'error_cooldown': self._current_error_cooldown,
            'error_folder': self.error_folder,
            'comparison_method': self.current_comparison_method,
            'ssim_threshold': self._current_ssim_threshold,
            'yolo_confidence': self.config.get('yolo_confidence', DEFAULT_YOLO_CONFIDENCE),
        }

    def get_reference_data_for_worker(self):
        if self.current_comparison_method == METHOD_SSIM:
            return {k: (img.copy() if isinstance(img, np.ndarray) else None) for k, img in self.ref_data.items()}
        elif self.current_comparison_method == METHOD_YOLO:
            # --- ƒê·ªãnh nghƒ©a quy t·∫Øc YOLO t·∫°i ƒë√¢y ---
            return {
                REF_NORM: {"required_objects": ["person"], "min_counts": {"person": 1}, "exact_total_objects": 1, "forbidden_objects": ["alert"]},
                REF_SHUTDOWN: {"forbidden_objects": ["person"], "max_total_objects": 0},
                REF_FAIL: {"any_of": ["alert", "warning"]},
            }
        else:
            return {}

    # --- Config Update Slots gi·ªØ nguy√™n ---
    @QtCore.pyqtSlot(float)
    def _update_threshold_config(self, value):
        if abs(self._current_ssim_threshold - value) > 1e-4:
            self._current_ssim_threshold = value
            self.log_activity(f"‚öôÔ∏è Ng∆∞·ª°ng SSIM: {value:.3f}")
            self.config['ssim_threshold'] = value

    @QtCore.pyqtSlot(int)
    def _update_cooldown_config(self, value):
        if self._current_error_cooldown != value:
            self._current_error_cooldown = value
            self.log_activity(f"‚öôÔ∏è Cooldown L·ªói: {value}s")
            self.config['error_cooldown'] = value

    @QtCore.pyqtSlot(int)
    def _update_runtime_config(self, value):
        if self._current_runtime_minutes != value:
            self._current_runtime_minutes = value
            log_msg = f"‚öôÔ∏è Th·ªùi gian ch·∫°y: {'V√¥ h·∫°n' if value == 0 else f'{value} ph√∫t'}"
            self.log_activity(log_msg)
            self.config['runtime_duration_minutes'] = value

    @QtCore.pyqtSlot()
    def _toggle_record_on_error(self):
        if self.processing:
             QMessageBox.warning(self,"ƒêang X·ª≠ L√Ω","Kh√¥ng th·ªÉ thay ƒë·ªïi khi ƒëang x·ª≠ l√Ω.")
             return
        self._record_on_error_enabled = not self._record_on_error_enabled
        self.config['record_on_error'] = self._record_on_error_enabled
        self.update_record_button_style()
        self.log_activity(f"‚öôÔ∏è Ghi video l·ªói: {'B·∫≠t' if self._record_on_error_enabled else 'T·∫Øt'}")

    @QtCore.pyqtSlot(str)
    def _update_serial_port_config(self, port_name):
        new_port = port_name if port_name and "Kh√¥ng t√¨m th·∫•y" not in port_name else None
        if self.serial_port_name != new_port:
             self.serial_port_name = new_port
             self.config['serial_port'] = self.serial_port_name
             self.log_activity(f"‚öôÔ∏è C·ªïng COM: {self.serial_port_name or 'Ch∆∞a ch·ªçn'}")
             if self.serial_enabled: self.log_activity("‚ö†Ô∏è Thay ƒë·ªïi c·ªïng COM y√™u c·∫ßu K·∫øt n·ªëi l·∫°i.")

    @QtCore.pyqtSlot(str)
    def _update_serial_baud_config(self, baud_str):
        try:
            bd = int(baud_str)
            if self.serial_baud_rate != bd:
                if bd in COMMON_BAUD_RATES:
                    self.serial_baud_rate = bd
                    self.config['serial_baud'] = bd
                    self.log_activity(f"‚öôÔ∏è Baud rate: {bd}")
                    if self.serial_enabled: self.log_activity("‚ö†Ô∏è Thay ƒë·ªïi Baud rate y√™u c·∫ßu K·∫øt n·ªëi l·∫°i.")
                else:
                     self.log_activity(f"‚ö†Ô∏è Baud rate kh√¥ng h·ª£p l·ªá: {bd}. S·ª≠ d·ª•ng gi√° tr·ªã c≈©: {self.serial_baud_rate}")
                     idx = self.baudRateComboBox.findText(str(self.serial_baud_rate))
                     if idx >= 0: self.baudRateComboBox.blockSignals(True); self.baudRateComboBox.setCurrentIndex(idx); self.baudRateComboBox.blockSignals(False)
        except ValueError:
            self.log_activity(f"‚ö†Ô∏è Gi√° tr·ªã Baud rate nh·∫≠p v√†o kh√¥ng ph·∫£i s·ªë: {baud_str}")
            idx = self.baudRateComboBox.findText(str(self.serial_baud_rate))
            if idx >= 0: self.baudRateComboBox.blockSignals(True); self.baudRateComboBox.setCurrentIndex(idx); self.baudRateComboBox.blockSignals(False)

    @QtCore.pyqtSlot(str)
    def _update_comparison_method_config(self, method_name):
        if self.processing:
            self.log_activity("‚ö†Ô∏è Kh√¥ng th·ªÉ thay ƒë·ªïi ph∆∞∆°ng th·ª©c khi ƒëang x·ª≠ l√Ω.")
            self.comparisonMethodComboBox.blockSignals(True)
            self.comparisonMethodComboBox.setCurrentText(self.current_comparison_method)
            self.comparisonMethodComboBox.blockSignals(False)
            return

        if method_name in self.comparison_functions and self.current_comparison_method != method_name:
            if method_name == METHOD_YOLO and not YOLO_AVAILABLE:
                 QMessageBox.critical(self, "L·ªói Thi·∫øu Th∆∞ Vi·ªán", "Kh√¥ng t√¨m th·∫•y th∆∞ vi·ªán YOLOv8 (ultralytics).")
                 self.comparisonMethodComboBox.blockSignals(True)
                 self.comparisonMethodComboBox.setCurrentText(self.current_comparison_method)
                 self.comparisonMethodComboBox.blockSignals(False)
                 return

            self.current_comparison_method = method_name
            self.config['comparison_method'] = method_name
            self.log_activity(f"‚öôÔ∏è Ph∆∞∆°ng th·ª©c so s√°nh: {method_name}")
            self._update_method_specific_ui()
            if method_name == METHOD_YOLO and self.config.get('yolo_model_path'):
                # T·∫£i model (c√≥ th·ªÉ t√°ch ra th√†nh h√†m ri√™ng n·∫øu ph·ª©c t·∫°p)
                self._load_yolo_model()

    @QtCore.pyqtSlot(float)
    def _update_yolo_confidence_config(self, value):
         current_conf = self.config.get('yolo_confidence', DEFAULT_YOLO_CONFIDENCE)
         if abs(current_conf - value) > 1e-4: # So s√°nh s·ªë th·ª±c
             self.config['yolo_confidence'] = value
             self.log_activity(f"‚öôÔ∏è Ng∆∞·ª°ng tin c·∫≠y YOLO: {value:.2f}")

    # --- init_ui ---
    def init_ui(self):
        """Kh·ªüi t·∫°o giao di·ªán ng∆∞·ªùi d√πng."""
        self.setWindowTitle("Image Checker v3.0 (YOLOv8 Fixed)")
        self.setGeometry(100, 100, 1350, 820) # K√≠ch th∆∞·ªõc c·ª≠a s·ªï
        central_widget = QWidget(self)
        self.setCentralWidget(central_widget)

        # --- Panel Tr√°i: Hi·ªÉn th·ªã Webcam v√† N√∫t ƒëi·ªÅu khi·ªÉn c∆° b·∫£n ---
        self.scene = QGraphicsScene(self)
        self.graphicsView = QGraphicsView(self.scene, central_widget)
        self.graphicsView.setGeometry(10, 10, 640, 360)
        self.graphicsView.setStyleSheet("border: 1px solid black;")
        self.graphicsView.setBackgroundBrush(QtGui.QBrush(Qt.darkGray))

        # K√≠ch th∆∞·ªõc v√† v·ªã tr√≠ n√∫t
        bw, bh, vs, bx, yp = 201, 31, 40, 20, 380 # width, height, vertical_space, x_pos, y_start_pos
        # Webcam Controls
        self.ONCam = self.create_button("üì∑ B·∫≠t Webcam"); self.ONCam.setGeometry(bx, yp, bw, bh); self.ONCam.clicked.connect(self.start_webcam)
        self.OFFCam = self.create_button("üö´ T·∫Øt Webcam"); self.OFFCam.setGeometry(bx + bw + 10, yp, bw, bh); self.OFFCam.clicked.connect(self.stop_webcam); self.OFFCam.setEnabled(False); yp += vs
        # Load Reference Image Buttons (for SSIM)
        self.SettingButton_Norm = self.create_button("üìÇ ·∫¢nh Norm (SSIM)"); self.SettingButton_Norm.setGeometry(bx, yp, bw, bh); self.SettingButton_Norm.clicked.connect(lambda: self.load_reference_image(REF_NORM))
        self.SettingButton_Shutdown = self.create_button("üìÇ ·∫¢nh Shutdown (SSIM)"); self.SettingButton_Shutdown.setGeometry(bx + bw + 10, yp, bw, bh); self.SettingButton_Shutdown.clicked.connect(lambda: self.load_reference_image(REF_SHUTDOWN))
        self.SettingButton_Fail = self.create_button("üìÇ ·∫¢nh Fail (SSIM)"); self.SettingButton_Fail.setGeometry(bx + 2 * (bw + 10), yp, bw, bh); self.SettingButton_Fail.clicked.connect(lambda: self.load_reference_image(REF_FAIL)); yp += vs
        # Capture Reference Image Buttons (for SSIM)
        self.CaptureButton_Norm = self.create_button("üì∏ Ch·ª•p Norm (SSIM)"); self.CaptureButton_Norm.setGeometry(bx, yp, bw, bh); self.CaptureButton_Norm.clicked.connect(lambda: self.capture_reference_from_webcam(REF_NORM)); self.CaptureButton_Norm.setEnabled(False)
        self.CaptureButton_Shut = self.create_button("üì∏ Ch·ª•p Shutdown (SSIM)"); self.CaptureButton_Shut.setGeometry(bx + bw + 10, yp, bw, bh); self.CaptureButton_Shut.clicked.connect(lambda: self.capture_reference_from_webcam(REF_SHUTDOWN)); self.CaptureButton_Shut.setEnabled(False)
        self.CaptureButton_Fail = self.create_button("üì∏ Ch·ª•p Fail (SSIM)"); self.CaptureButton_Fail.setGeometry(bx + 2 * (bw + 10), yp, bw, bh); self.CaptureButton_Fail.clicked.connect(lambda: self.capture_reference_from_webcam(REF_FAIL)); self.CaptureButton_Fail.setEnabled(False); yp += vs
        # ROI, Save Folder, Start/Stop Buttons
        self.SettingButton_ROI_Webcam = self.create_button("‚úÇÔ∏è Ch·ªçn ROI"); self.SettingButton_ROI_Webcam.setGeometry(bx, yp, bw, bh); self.SettingButton_ROI_Webcam.clicked.connect(self.select_webcam_roi); self.SettingButton_ROI_Webcam.setEnabled(False)
        self.SaveButton = self.create_button("üìÅ Th∆∞ m·ª•c l·ªói"); self.SaveButton.setGeometry(bx + bw + 10, yp, bw, bh); self.SaveButton.clicked.connect(self.select_error_folder)
        self.ToggleProcessingButton = self.create_button("‚ñ∂Ô∏è B·∫Øt ƒë·∫ßu"); self.ToggleProcessingButton.setGeometry(bx + 2 * (bw + 10), yp, bw, bh); self.ToggleProcessingButton.clicked.connect(self.toggle_processing); yp += vs
        # Exit Button
        self.ExitButton = self.create_button("üö™ Tho√°t"); self.ExitButton.setGeometry(bx, yp, bw, bh); self.ExitButton.clicked.connect(self.close_application)


        # --- Panel Ph·∫£i: Log, Tr·∫°ng th√°i, C·∫•u h√¨nh ---
        rx = 670 # X-start for right panel
        lw = self.geometry().width() - rx - 20 # width for right panel elements
        # Log Area
        log_label = QLabel("Log Ho·∫°t ƒê·ªông:", central_widget); log_label.setGeometry(rx, 10, 150, 20)
        self.log_text_edit = QTextEdit(central_widget); self.log_text_edit.setGeometry(rx, 35, lw, 250); self.log_text_edit.setReadOnly(True); self.log_text_edit.setStyleSheet("border:1px solid black; padding:5px; background-color:white; font-family:Consolas,monospace; font-size:10pt;")
        # Status Labels
        self.process_label = QLabel("Tr·∫°ng th√°i: Ch·ªù", central_widget); self.process_label.setGeometry(rx, 300, lw, 40); self.process_label.setAlignment(Qt.AlignCenter); self.process_label.setStyleSheet("border:1px solid black; padding:5px; background-color:lightgray; font-weight:bold; border-radius:3px;")
        self.details_label = QLabel("Details: N/A", central_widget); self.details_label.setGeometry(rx, 345, lw, 30); self.details_label.setAlignment(Qt.AlignCenter); self.details_label.setStyleSheet("padding:5px; background-color:#f0f0f0; border-radius:3px;")

        # V·ªã tr√≠ c√°c control c·∫•u h√¨nh
        sx_lbl = rx + 10      # X-pos for labels in settings
        sx_ctrl = sx_lbl + 150 # X-pos for controls (spinbox, combobox)
        sy = 390              # Y-start pos for settings section
        s_vs = 38             # Vertical spacing for settings rows
        ctrl_w = 190          # Width for spinbox/combobox
        btn_w_sm = 40         # Width for small buttons (like refresh)
        lbl_w = 140           # Width for labels

        # --- Method Selection ---
        lm = QLabel("Ph∆∞∆°ng th·ª©c:", central_widget); lm.setGeometry(sx_lbl, sy, lbl_w, 31)
        self.comparisonMethodComboBox = QComboBox(central_widget); self.comparisonMethodComboBox.setGeometry(sx_ctrl, sy, ctrl_w + 50, 31) # Make wider
        self.comparisonMethodComboBox.addItems([METHOD_SSIM, METHOD_YOLO])
        self.comparisonMethodComboBox.setToolTip("Ch·ªçn thu·∫≠t to√°n so s√°nh ·∫£nh")
        self.comparisonMethodComboBox.currentTextChanged.connect(self._update_comparison_method_config); sy += s_vs

        # --- SSIM Specific Group ---
        self.ssimGroup = QGroupBox("C·∫•u h√¨nh SSIM", central_widget)
        self.ssimGroup.setGeometry(rx, sy, lw, s_vs + 10)
        self.ssimThresholdLabel = QLabel("Ng∆∞·ª°ng SSIM:", self.ssimGroup); self.ssimThresholdLabel.setGeometry(10, 10, lbl_w - 10, 31)
        self.ssimThresholdSpinBox = QDoubleSpinBox(self.ssimGroup); self.ssimThresholdSpinBox.setGeometry(sx_ctrl - rx, 10, ctrl_w, 31)
        self.ssimThresholdSpinBox.setRange(0.1, 1.0); self.ssimThresholdSpinBox.setSingleStep(0.01); self.ssimThresholdSpinBox.setDecimals(3)
        self.ssimThresholdSpinBox.valueChanged.connect(self._update_threshold_config); sy += s_vs + 15 # Move Y below this group

        # --- YOLOv8 Specific Group ---
        self.yoloGroup = QGroupBox("C·∫•u h√¨nh YOLOv8", central_widget)
        self.yoloGroup.setGeometry(rx, sy, lw, s_vs * 2 + 15) # Taller group
        # Model Path Row
        lyp = QLabel("Model Path:", self.yoloGroup); lyp.setGeometry(10, 10, lbl_w - 10, 31)
        self.yoloModelPathButton = QPushButton("üìÅ Ch·ªçn Model (.pt)", self.yoloGroup); self.yoloModelPathButton.setGeometry(sx_ctrl - rx, 10, ctrl_w, 31); self.yoloModelPathButton.clicked.connect(self._select_yolo_model_path)
        self.yoloModelPathLabel = QLabel("Ch∆∞a ch·ªçn model", self.yoloGroup); self.yoloModelPathLabel.setGeometry(sx_ctrl - rx + ctrl_w + 5, 10, lw - (sx_ctrl - rx + ctrl_w + 5) - 10, 31); self.yoloModelPathLabel.setStyleSheet("font-style: italic; color: gray;")
        # Confidence Row
        self.yoloConfidenceLabel = QLabel("Ng∆∞·ª°ng Conf:", self.yoloGroup); self.yoloConfidenceLabel.setGeometry(10, 10 + s_vs, lbl_w - 10, 31)
        self.yoloConfidenceSpinBox = QDoubleSpinBox(self.yoloGroup); self.yoloConfidenceSpinBox.setGeometry(sx_ctrl - rx, 10 + s_vs, ctrl_w, 31)
        self.yoloConfidenceSpinBox.setRange(0.05, 1.0); self.yoloConfidenceSpinBox.setSingleStep(0.05); self.yoloConfidenceSpinBox.setDecimals(2)
        self.yoloConfidenceSpinBox.setToolTip("Ng∆∞·ª°ng tin c·∫≠y t·ªëi thi·ªÉu cho YOLO detection")
        self.yoloConfidenceSpinBox.valueChanged.connect(self._update_yolo_confidence_config); sy += s_vs * 2 + 20 # Move Y below this group

        # --- Common Settings ---
        lc = QLabel("Cooldown L·ªói (s):", central_widget); lc.setGeometry(sx_lbl, sy, lbl_w, 31)
        self.cooldownSpinBox = QSpinBox(central_widget); self.cooldownSpinBox.setGeometry(sx_ctrl, sy, ctrl_w, 31); self.cooldownSpinBox.setRange(1, 300); self.cooldownSpinBox.setSingleStep(1); self.cooldownSpinBox.valueChanged.connect(self._update_cooldown_config); sy += s_vs
        lr = QLabel("Th·ªùi gian ch·∫°y (ph√∫t):", central_widget); lr.setGeometry(sx_lbl, sy, lbl_w, 31)
        self.runtimeSpinBox = QSpinBox(central_widget); self.runtimeSpinBox.setGeometry(sx_ctrl, sy, ctrl_w, 31); self.runtimeSpinBox.setRange(0, 1440); self.runtimeSpinBox.setSingleStep(10); self.runtimeSpinBox.setToolTip("0 = Ch·∫°y v√¥ h·∫°n"); self.runtimeSpinBox.valueChanged.connect(self._update_runtime_config); sy += s_vs
        self.ToggleRecordOnErrorButton = self.create_button("üé• Quay video l·ªói: T·∫Øt"); self.ToggleRecordOnErrorButton.setGeometry(sx_lbl, sy, ctrl_w + 50, 31); self.ToggleRecordOnErrorButton.clicked.connect(self._toggle_record_on_error); sy += s_vs

        # --- Serial Port Settings Group ---
        self.serialGroup = QGroupBox("C·∫•u h√¨nh Serial COM", central_widget)
        self.serialGroup.setGeometry(rx, sy, lw, s_vs * 3 + 15) # Adjust height
        sy_serial = 10 # Y inside this groupbox
        # COM Port Row
        lcp = QLabel("C·ªïng COM:", self.serialGroup); lcp.setGeometry(10, sy_serial, lbl_w - 10, 31)
        self.comPortComboBox = QComboBox(self.serialGroup); self.comPortComboBox.setGeometry(sx_ctrl - rx, sy_serial, ctrl_w - btn_w_sm - 5, 31); self.comPortComboBox.currentTextChanged.connect(self._update_serial_port_config)
        self.refreshComButton = QPushButton("üîÑ", self.serialGroup); self.refreshComButton.setGeometry(sx_ctrl - rx + ctrl_w - btn_w_sm, sy_serial, btn_w_sm, 31); self.refreshComButton.clicked.connect(self._refresh_com_ports); sy_serial += s_vs
        # Baud Rate Row
        lbr = QLabel("Baud Rate:", self.serialGroup); lbr.setGeometry(10, sy_serial, lbl_w - 10, 31)
        self.baudRateComboBox = QComboBox(self.serialGroup); self.baudRateComboBox.setGeometry(sx_ctrl - rx, sy_serial, ctrl_w, 31); self.baudRateComboBox.addItems([str(br) for br in COMMON_BAUD_RATES]); self.baudRateComboBox.currentTextChanged.connect(self._update_serial_baud_config); sy_serial += s_vs
        # Toggle Connect/Disconnect Button
        self.ToggleSerialPortButton = self.create_button("üîå K·∫øt n·ªëi COM"); self.ToggleSerialPortButton.setGeometry(10, sy_serial, ctrl_w + 50, 31); self.ToggleSerialPortButton.clicked.connect(self._toggle_serial_port)
        # sy += s_vs * 3 + 20 # Final Y position update if needed after this group

        # Initial UI state update after widgets are created
        self._update_method_specific_ui() # Hide/show SSIM/YOLO groups

    def create_button(self, text):
        """H√†m tr·ª£ gi√∫p t·∫°o QPushButton v·ªõi style chu·∫©n."""
        button = QPushButton(text, self.centralWidget())
        # T√πy ch·ªânh style th√™m n·∫øu c·∫ßn
        return button

    # --- Config Save/Load/Reset ---
    def save_config(self):
        """L∆∞u c·∫•u h√¨nh hi·ªán t·∫°i v√†o file JSON."""
        self.config['comparison_method'] = self.current_comparison_method
        self.config['ssim_threshold'] = self._current_ssim_threshold
        self.config['error_cooldown'] = self._current_error_cooldown
        self.config['runtime_duration_minutes'] = self._current_runtime_minutes
        self.config['record_on_error'] = self._record_on_error_enabled
        self.config['error_folder'] = self.error_folder
        self.config['webcam_roi'] = list(self.webcam_roi) if self.webcam_roi else None
        # L·∫•y gi√° tr·ªã YOLO conf t·ª´ UI
        self.config['yolo_confidence'] = self.yoloConfidenceSpinBox.value()
        # yolo_model_path ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t trong _select_yolo_model_path

        # Ch·ªâ l∆∞u ƒë∆∞·ªùng d·∫´n ·∫£nh SSIM n·∫øu ·∫£nh th·ª±c s·ª± t·ªìn t·∫°i v√† ƒë∆∞·ª£c load t·ª´ file
        valid_ref_paths = {}
        for k, img in self.ref_data.items():
            path_in_config = self.config['ref_paths'].get(k)
            if isinstance(img, np.ndarray) and img.size > 0 and isinstance(path_in_config, str) and os.path.isfile(path_in_config):
                valid_ref_paths[k] = path_in_config
        self.config['ref_paths'] = valid_ref_paths

        self.config['serial_port'] = self.serial_port_name
        self.config['serial_baud'] = self.serial_baud_rate
        # L∆∞u tr·∫°ng th√°i cu·ªëi nh∆∞ng kh√¥ng t·ª± k·∫øt n·ªëi l·∫°i khi t·∫£i
        self.config['serial_enabled'] = self.serial_enabled

        try:
            # T·∫°o th∆∞ m·ª•c n·∫øu ch∆∞a c√≥
            config_dir = os.path.dirname(CONFIG_FILE_NAME)
            if config_dir and not os.path.exists(config_dir):
                os.makedirs(config_dir, exist_ok=True)
            # Ghi file JSON
            with open(CONFIG_FILE_NAME, 'w', encoding='utf-8') as f:
                json.dump(self.config, f, indent=4, ensure_ascii=False)
        except Exception as e:
            self.log_activity(f"‚ùå L·ªói khi l∆∞u c·∫•u h√¨nh: {e}")
            QMessageBox.critical(self, "L·ªói L∆∞u Config", f"Kh√¥ng th·ªÉ l∆∞u c·∫•u h√¨nh v√†o file:\n{CONFIG_FILE_NAME}\n\nL·ªói: {e}")

    def load_config(self):
        """T·∫£i c·∫•u h√¨nh t·ª´ file JSON, x·ª≠ l√Ω l·ªói v√† gi√° tr·ªã m·∫∑c ƒë·ªãnh."""
        if not os.path.exists(CONFIG_FILE_NAME):
            self.log_activity(f"üìÑ Kh√¥ng t√¨m th·∫•y file config '{CONFIG_FILE_NAME}'. S·ª≠ d·ª•ng m·∫∑c ƒë·ªãnh.")
            self.reset_to_defaults()
            return # Tho√°t kh·ªèi h√†m sau khi reset

        try:
            with open(CONFIG_FILE_NAME, 'r', encoding='utf-8') as f:
                lcfg = json.load(f) # Loaded config from file

            # 1. T·∫£i ph∆∞∆°ng th·ª©c so s√°nh
            loaded_method = lcfg.get('comparison_method', DEFAULT_COMPARISON_METHOD)
            if loaded_method in self.comparison_functions:
                # Ki·ªÉm tra ƒë·∫∑c bi·ªát n·∫øu ch·ªçn YOLO m√† th∆∞ vi·ªán ch∆∞a c√†i
                if loaded_method == METHOD_YOLO and not YOLO_AVAILABLE:
                    self.log_activity(f"‚ö†Ô∏è YOLO ƒë∆∞·ª£c ch·ªçn nh∆∞ng ch∆∞a c√†i ƒë·∫∑t. ƒê·ªïi v·ªÅ {DEFAULT_COMPARISON_METHOD}.")
                    self.current_comparison_method = DEFAULT_COMPARISON_METHOD
                else:
                    self.current_comparison_method = loaded_method
            else: # Ph∆∞∆°ng th·ª©c trong file config kh√¥ng h·ª£p l·ªá
                self.log_activity(f"‚ö†Ô∏è Ph∆∞∆°ng th·ª©c '{loaded_method}' kh√¥ng h·ª£p l·ªá. D√πng m·∫∑c ƒë·ªãnh.")
                self.current_comparison_method = DEFAULT_COMPARISON_METHOD

            # 2. T·∫£i c√°c c·∫•u h√¨nh kh√°c v·ªõi validation v√† gi√° tr·ªã m·∫∑c ƒë·ªãnh
            try: self._current_ssim_threshold = max(0.1, min(1.0, float(lcfg.get('ssim_threshold', DEFAULT_SSIM_THRESHOLD))))
            except (ValueError, TypeError): self._current_ssim_threshold = DEFAULT_SSIM_THRESHOLD
            try: self._current_error_cooldown = max(1, min(300, int(lcfg.get('error_cooldown', DEFAULT_ERROR_COOLDOWN))))
            except (ValueError, TypeError): self._current_error_cooldown = DEFAULT_ERROR_COOLDOWN
            try: self._current_runtime_minutes = max(0, min(1440, int(lcfg.get('runtime_duration_minutes', DEFAULT_RUNTIME_MINUTES))))
            except (ValueError, TypeError): self._current_runtime_minutes = DEFAULT_RUNTIME_MINUTES
            lrec = lcfg.get('record_on_error', DEFAULT_RECORD_ON_ERROR)
            self._record_on_error_enabled = bool(lrec) if isinstance(lrec, bool) else DEFAULT_RECORD_ON_ERROR

            # 3. T·∫£i c·∫•u h√¨nh Serial (Lu√¥n ƒë·∫∑t enabled=False khi t·∫£i)
            self.serial_port_name = lcfg.get('serial_port', None)
            if not isinstance(self.serial_port_name, (str, type(None))): self.serial_port_name = None # Validate type
            try:
                baud = int(lcfg.get('serial_baud', DEFAULT_BAUD_RATE))
                self.serial_baud_rate = baud if baud in COMMON_BAUD_RATES else DEFAULT_BAUD_RATE
            except (ValueError, TypeError): self.serial_baud_rate = DEFAULT_BAUD_RATE
            self.serial_enabled = False # B·∫Øt bu·ªôc k·∫øt n·ªëi l·∫°i th·ªß c√¥ng

            # 4. T·∫£i Th∆∞ m·ª•c l·ªói v√† ROI (v·ªõi ki·ªÉm tra)
            lfold = lcfg.get('error_folder'); self.error_folder = None
            if lfold and isinstance(lfold, str) and os.path.isdir(lfold) and os.access(lfold, os.W_OK):
                self.error_folder = lfold
            else:
                 if lfold: self.log_activity(f"‚ö†Ô∏è Th∆∞ m·ª•c l·ªói '{lfold}' kh√¥ng h·ª£p l·ªá ho·∫∑c kh√¥ng ghi ƒë∆∞·ª£c.")

            lroi = lcfg.get('webcam_roi'); self.webcam_roi = None
            if isinstance(lroi, list) and len(lroi) == 4:
                 try:
                     rt = tuple(int(x) for x in lroi)
                     if all(v >= 0 for v in rt) and rt[2] > 0 and rt[3] > 0: self.webcam_roi = rt
                 except (ValueError, TypeError): pass # B·ªè qua ROI kh√¥ng h·ª£p l·ªá

            # 5. T·∫£i ƒë∆∞·ªùng d·∫´n ·∫£nh SSIM v√† load ·∫£nh
            lrefs = lcfg.get('ref_paths', {})
            self.config['ref_paths'] = {k: None for k in self.ref_data.keys()} # Reset trong config
            self.ref_data = {k: None for k in self.ref_data.keys()} # Reset ·∫£nh ƒë√£ t·∫£i
            loaded_image_keys = []
            # ---- S·ª¨A L·ªñI C√ö PH√ÅP T·∫†I ƒê√ÇY ----
            for k in self.ref_data.keys():
                p = lrefs.get(k)
                if p and isinstance(p, str) and os.path.isfile(p):
                    try:
                        # S·ª≠ d·ª•ng np.fromfile v√† cv2.imdecode ƒë·ªÉ x·ª≠ l√Ω ƒë∆∞·ªùng d·∫´n unicode
                        img_bytes = np.fromfile(p, dtype=np.uint8)
                        img = cv2.imdecode(img_bytes, cv2.IMREAD_COLOR)
                        if img is not None:
                            self.ref_data[k] = img           # Th·ª•t l·ªÅ ƒë√∫ng, b·ªè d·∫•u ;
                            self.config['ref_paths'][k] = p  # Th·ª•t l·ªÅ ƒë√∫ng, b·ªè d·∫•u ;
                            loaded_image_keys.append(k)    # Th·ª•t l·ªÅ ƒë√∫ng, b·ªè d·∫•u ;
                        # else: Kh√¥ng c·∫ßn b√°o l·ªói n·∫øu decode th·∫•t b·∫°i, coi nh∆∞ file h·ªèng
                    except Exception as e:
                        # Ghi log n·∫øu c√≥ l·ªói kh√°c khi ƒë·ªçc file
                        self.log_activity(f"‚ö†Ô∏è L·ªói khi t·∫£i ·∫£nh SSIM '{k}' t·ª´ '{p}': {e}")
            # ---------------------------------
            if loaded_image_keys: self.log_activity(f"‚úÖ T·∫£i ·∫£nh SSIM: {', '.join(loaded_image_keys)}")

            # 6. T·∫£i c·∫•u h√¨nh YOLO
            self.config['yolo_model_path'] = lcfg.get('yolo_model_path', None)
            if self.config['yolo_model_path'] and not isinstance(self.config['yolo_model_path'], str):
                 self.config['yolo_model_path'] = None # ƒê·∫£m b·∫£o l√† string ho·∫∑c None
            try:
                yolo_conf = float(lcfg.get('yolo_confidence', DEFAULT_YOLO_CONFIDENCE))
                # ƒê·∫£m b·∫£o gi√° tr·ªã trong kho·∫£ng h·ª£p l·ªá
                self.config['yolo_confidence'] = max(0.01, min(1.0, yolo_conf))
            except (ValueError, TypeError):
                self.config['yolo_confidence'] = DEFAULT_YOLO_CONFIDENCE

            # 7. C·∫≠p nh·∫≠t dict config cu·ªëi c√πng sau khi t·∫£i
            # (C√°c gi√° tr·ªã ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t v√†o self.config ho·∫∑c c√°c bi·∫øn state trong c√°c b∆∞·ªõc tr√™n)
            # Ch·ªâ c·∫ßn ƒë·∫£m b·∫£o self.config ph·∫£n √°nh ƒë√∫ng tr·∫°ng th√°i cu·ªëi c√πng
            # V√≠ d·ª•: C·∫≠p nh·∫≠t l·∫°i nh·ªØng g√¨ ch∆∞a ƒë∆∞·ª£c g√°n tr·ª±c ti·∫øp v√†o self.config
            self.config.update({
                'comparison_method': self.current_comparison_method,
                'ssim_threshold': self._current_ssim_threshold,
                'error_cooldown': self._current_error_cooldown,
                'runtime_duration_minutes': self._current_runtime_minutes,
                'record_on_error': self._record_on_error_enabled,
                'error_folder': self.error_folder,
                'webcam_roi': list(self.webcam_roi) if self.webcam_roi else None,
                'serial_port': self.serial_port_name,
                'serial_baud': self.serial_baud_rate,
                'serial_enabled': self.serial_enabled, # S·∫Ω l√† False
                # ref_paths, yolo_model_path, yolo_confidence ƒë√£ c·∫≠p nh·∫≠t
            })

            # 8. C·∫≠p nh·∫≠t ƒë∆∞·ªùng d·∫´n file log
            self.log_file_path = os.path.join(self.error_folder, LOG_FILE_NAME) if self.error_folder else None
            self.log_activity(f"üíæ ƒê√£ t·∫£i c·∫•u h√¨nh t·ª´ '{CONFIG_FILE_NAME}'.")

        except json.JSONDecodeError as e:
             # L·ªói khi ph√¢n t√≠ch file JSON
             self.log_activity(f"‚ùå L·ªói JSON trong file config: {e}. S·ª≠ d·ª•ng m·∫∑c ƒë·ªãnh.")
             self.reset_to_defaults()
        # ---- S·ª¨A L·ªñI C√ö PH√ÅP T·∫†I ƒê√ÇY ----
        except Exception as e:
             # B·∫Øt t·∫•t c·∫£ c√°c l·ªói kh√°c c√≥ th·ªÉ x·∫£y ra khi t·∫£i config
             self.log_activity(f"‚ùå L·ªói nghi√™m tr·ªçng khi t·∫£i config: {e}. S·ª≠ d·ª•ng m·∫∑c ƒë·ªãnh.")
             self.log_activity(traceback.format_exc())
             self.reset_to_defaults() # Th·ª•t l·ªÅ ƒë√∫ng cho h√†m n√†y
        # ---------------------------------

    # --- C√°c h√†m c√≤n l·∫°i gi·ªØ nguy√™n ho·∫∑c ch·ªâ s·ª≠a nh·ªè ---
    # (reset_to_defaults, update_all_ui_elements, _update_method_specific_ui,
    #  log_activity, update_status_label, update_details_display, _call_lambda_slot,
    #  _set_button_style, update_button_styles, update_toggle_button_text,
    #  update_record_button_style, update_serial_button_style, start_webcam,
    #  update_frame, stop_webcam, load_reference_image, capture_reference_from_webcam,
    #  select_webcam_roi, select_error_folder, _refresh_com_ports, _toggle_serial_port,
    #  _send_serial_command, _select_yolo_model_path, _load_yolo_model,
    #  toggle_processing, _mark_error_occurred, disable_settings_while_processing,
    #  _runtime_timer_timeout, compare_ssim_strategy, compare_yolo_strategy,
    #  _check_yolo_rule, save_error_image_from_thread, close_application, closeEvent)
    def reset_to_defaults(self):
        self.log_activity("üîÑ Reset v·ªÅ m·∫∑c ƒë·ªãnh...")
        self.current_comparison_method = DEFAULT_COMPARISON_METHOD
        self._current_ssim_threshold=DEFAULT_SSIM_THRESHOLD
        self._current_error_cooldown=DEFAULT_ERROR_COOLDOWN
        self._current_runtime_minutes=DEFAULT_RUNTIME_MINUTES
        self._record_on_error_enabled=DEFAULT_RECORD_ON_ERROR
        self.error_folder=None; self.log_file_path=None; self.webcam_roi=None
        self.ref_data={k:None for k in[REF_NORM,REF_SHUTDOWN,REF_FAIL]}
        # Gi·∫£i ph√≥ng model YOLO n·∫øu ƒëang c√≥
        if self.yolo_model is not None: del self.yolo_model; self.yolo_model = None

        # Reset Serial
        self.serial_port_name=None; self.serial_baud_rate=DEFAULT_BAUD_RATE; self.serial_enabled=False
        if self.serial_port and self.serial_port.is_open:
            try: self.serial_port.close()
            except Exception: pass # B·ªè qua l·ªói khi ƒë√≥ng ·ªü ƒë√¢y
        self.serial_port=None

        # Reset Config Dictionary v·ªÅ m·∫∑c ƒë·ªãnh
        self.config={
            'comparison_method': DEFAULT_COMPARISON_METHOD,
            'ssim_threshold': DEFAULT_SSIM_THRESHOLD,
            'error_cooldown': DEFAULT_ERROR_COOLDOWN,
            'runtime_duration_minutes': DEFAULT_RUNTIME_MINUTES,
            'record_on_error': DEFAULT_RECORD_ON_ERROR,
            'error_folder': None,
            'ref_paths': {k:None for k in [REF_NORM, REF_SHUTDOWN, REF_FAIL]},
            'webcam_roi': None,
            'serial_port': None,
            'serial_baud': DEFAULT_BAUD_RATE,
            'serial_enabled': False,
            'yolo_model_path': None,
            'yolo_confidence': DEFAULT_YOLO_CONFIDENCE,
        }
        # C·∫≠p nh·∫≠t l·∫°i giao di·ªán sau khi reset
        # S·ª≠ d·ª•ng hasattr ƒë·ªÉ ki·ªÉm tra xem UI ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o ch∆∞a (ph√≤ng tr∆∞·ªùng h·ª£p l·ªói s·ªõm)
        if hasattr(self, 'comparisonMethodComboBox'):
            self.update_all_ui_elements()
        self.save_config() # L∆∞u l·∫°i file config v·ªõi gi√° tr·ªã m·∫∑c ƒë·ªãnh m·ªõi
        self.log_activity("üîÑ Ho√†n t·∫•t reset v·ªÅ m·∫∑c ƒë·ªãnh.")


    def update_all_ui_elements(self):
        """C·∫≠p nh·∫≠t t·∫•t c·∫£ c√°c control tr√™n UI ƒë·ªÉ ph·∫£n √°nh tr·∫°ng th√°i/config hi·ªán t·∫°i."""
        self.log_activity("‚ÑπÔ∏è C·∫≠p nh·∫≠t giao di·ªán ng∆∞·ªùi d√πng...")
        # Danh s√°ch c√°c control c·∫ßn ch·∫∑n t√≠n hi·ªáu khi c·∫≠p nh·∫≠t gi√° tr·ªã
        controls_to_block = [
            self.comparisonMethodComboBox, self.ssimThresholdSpinBox, self.yoloConfidenceSpinBox,
            self.cooldownSpinBox, self.runtimeSpinBox, self.comPortComboBox, self.baudRateComboBox
        ]
        # Ch·∫∑n t√≠n hi·ªáu
        for control in controls_to_block: control.blockSignals(True)

        # C·∫≠p nh·∫≠t gi√° tr·ªã cho t·ª´ng control t·ª´ self.config ho·∫∑c bi·∫øn tr·∫°ng th√°i
        try:
            self.comparisonMethodComboBox.setCurrentText(self.current_comparison_method)
            self.ssimThresholdSpinBox.setValue(self._current_ssim_threshold)
            self.yoloConfidenceSpinBox.setValue(self.config.get('yolo_confidence', DEFAULT_YOLO_CONFIDENCE))
            self.cooldownSpinBox.setValue(self._current_error_cooldown)
            self.runtimeSpinBox.setValue(self._current_runtime_minutes)
            self.baudRateComboBox.setCurrentText(str(self.serial_baud_rate))

            # C·∫≠p nh·∫≠t ComboBox c·ªïng COM (logic ph·ª©c t·∫°p h∆°n)
            com_index = self.comPortComboBox.findText(self.serial_port_name if self.serial_port_name else "")
            if self.serial_port_name and com_index >= 0:
                self.comPortComboBox.setCurrentIndex(com_index)
            elif self.comPortComboBox.count() > 0 and "Kh√¥ng t√¨m th·∫•y" not in self.comPortComboBox.itemText(0):
                # N·∫øu c·ªïng ƒë√£ l∆∞u kh√¥ng c√≥, nh∆∞ng c√≥ c·ªïng kh√°c, ch·ªçn c·ªïng ƒë·∫ßu ti√™n
                self.comPortComboBox.setCurrentIndex(0)
                # C·∫≠p nh·∫≠t l·∫°i serial_port_name n·∫øu c·∫ßn thi·∫øt (t√πy ch·ªçn)
                # self.serial_port_name = self.comPortComboBox.currentText()
                # self.config['serial_port'] = self.serial_port_name
            # else: Kh√¥ng c√≥ c·ªïng n√†o, kh√¥ng c·∫ßn l√†m g√¨ th√™m

            # C·∫≠p nh·∫≠t label ƒë∆∞·ªùng d·∫´n model YOLO
            model_path = self.config.get('yolo_model_path')
            if model_path and isinstance(model_path, str):
                self.yoloModelPathLabel.setText(os.path.basename(model_path))
                self.yoloModelPathLabel.setStyleSheet("font-style: normal; color: black;")
                self.yoloModelPathLabel.setToolTip(model_path)
            else:
                self.yoloModelPathLabel.setText("Ch∆∞a ch·ªçn model")
                self.yoloModelPathLabel.setStyleSheet("font-style: italic; color: gray;")
                self.yoloModelPathLabel.setToolTip("")

        except Exception as ui_update_err:
            self.log_activity(f"‚ùå L·ªói khi c·∫≠p nh·∫≠t gi√° tr·ªã UI: {ui_update_err}")
        finally:
            # B·ªè ch·∫∑n t√≠n hi·ªáu (lu√¥n th·ª±c hi·ªán)
            for control in controls_to_block: control.blockSignals(False)

        # C·∫≠p nh·∫≠t style n√∫t v√† hi·ªÉn th·ªã/·∫©n c√°c group
        self.update_button_styles()
        self.update_toggle_button_text()
        self.update_record_button_style()
        self.update_serial_button_style()
        self._update_method_specific_ui()
        # B·∫≠t/t·∫Øt control d·ª±a tr√™n tr·∫°ng th√°i processing
        self.disable_settings_while_processing(self.processing)
        self.log_activity("‚ÑπÔ∏è C·∫≠p nh·∫≠t giao di·ªán ho√†n t·∫•t.")


    def _update_method_specific_ui(self):
        """Hi·ªÉn th·ªã/·∫©n c√°c group c·∫•u h√¨nh SSIM/YOLO."""
        is_ssim = (self.current_comparison_method == METHOD_SSIM)
        is_yolo = (self.current_comparison_method == METHOD_YOLO)
        # S·ª≠ d·ª•ng hasattr ƒë·ªÉ ph√≤ng tr∆∞·ªùng h·ª£p UI ch∆∞a k·ªãp t·∫°o ƒë·∫ßy ƒë·ªß
        if hasattr(self, 'ssimGroup'): self.ssimGroup.setVisible(is_ssim)
        if hasattr(self, 'yoloGroup'): self.yoloGroup.setVisible(is_yolo)
        # C·∫≠p nh·∫≠t l·∫°i tooltip/text c·ªßa c√°c n√∫t li√™n quan n·∫øu c·∫ßn
        self.update_button_styles()


    # --- log_activity gi·ªØ nguy√™n ---
    @QtCore.pyqtSlot(str)
    def log_activity(self, message):
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        full_message = f"{timestamp} - {message}"
        if hasattr(self, 'log_text_edit'):
            # ƒê·∫£m b·∫£o thread-safe n·∫øu c·∫ßn (d√πng t√≠n hi·ªáu t·ª´ worker l√† ch√≠nh)
            if QtCore.QThread.currentThread() != self.log_text_edit.thread():
                QtCore.QMetaObject.invokeMethod(self.log_text_edit, "append", Qt.QueuedConnection, QtCore.Q_ARG(str, full_message))
                QtCore.QMetaObject.invokeMethod(self.log_text_edit, "ensureCursorVisible", Qt.QueuedConnection)
            else:
                self.log_text_edit.append(full_message)
                self.log_text_edit.ensureCursorVisible()
        # Ghi v√†o file log
        if self.log_file_path:
            try:
                log_dir = os.path.dirname(self.log_file_path)
                if log_dir and not os.path.exists(log_dir):
                     os.makedirs(log_dir, exist_ok=True)
                # M·ªü file ƒë·ªÉ ghi th√™m (append)
                with open(self.log_file_path, "a", encoding="utf-8") as log_file:
                    log_file.write(full_message + "\n")
            except Exception as e:
                # L·ªói nghi√™m tr·ªçng khi ghi log, th√¥ng b√°o v√† v√¥ hi·ªáu h√≥a ghi file
                print(f"CRITICAL: L·ªói ghi file log '{self.log_file_path}': {e}. V√¥ hi·ªáu h√≥a ghi log.")
                self.log_file_path = None


    # --- update_status_label, update_details_display, _call_lambda_slot gi·ªØ nguy√™n ---
    @QtCore.pyqtSlot(ComparisonStatus, object)
    def update_status_label(self, status_enum, details_dict):
        status_info = STATUS_MAP.get(status_enum, STATUS_MAP[ComparisonStatus.ERROR])
        message = status_info["label"]
        background_color = status_info["color"]
        _update = lambda: (
            self.process_label.setText(f"Tr·∫°ng th√°i: {message}"),
            self.process_label.setStyleSheet(f"border:1px solid black; padding:5px; background-color:{background_color}; color:black; font-weight:bold; border-radius:3px;")
        )
        if self.process_label.thread() != QtCore.QThread.currentThread():
             QtCore.QMetaObject.invokeMethod(self, "_call_lambda_slot", QtCore.Qt.QueuedConnection, QtCore.Q_ARG(object, _update))
        else: _update()

    @QtCore.pyqtSlot(dict)
    def update_details_display(self, details):
         display_text = "Details: N/A"
         if details:
             if 'detected' in details:
                 det_items = sorted([f"{k}:{v}" for k,v in details['detected'].items()])
                 display_text = f"Detect: {', '.join(det_items) if det_items else 'None'}"
                 if 'count' in details: display_text += f" (Total: {details['count']})"
             elif 'ssim_norm' in details:
                 display_text = f"SSIM(N): {details['ssim_norm']:.4f}"
                 if 'ssim_shutdown' in details: display_text += f", SSIM(S): {details['ssim_shutdown']:.4f}"
                 if 'ssim_fail' in details: display_text += f", SSIM(F): {details['ssim_fail']:.4f}"
             elif 'error' in details:
                 display_text = f"Error: {details['error']}"

             if 'reason' in details: display_text += f" [{details['reason']}]"

         _update = lambda: self.details_label.setText(display_text)
         if self.details_label.thread() != QtCore.QThread.currentThread():
             QtCore.QMetaObject.invokeMethod(self, "_call_lambda_slot", QtCore.Qt.QueuedConnection, QtCore.Q_ARG(object, _update))
         else: _update()

    @QtCore.pyqtSlot(object)
    def _call_lambda_slot(self, f): f()


    # --- C√°c h√†m c·∫≠p nh·∫≠t style n√∫t (_set_button_style, update_button_styles, etc.) gi·ªØ nguy√™n ---
    def _set_button_style(self, button, base_text, icon, state_text="", background_color="white", text_color="black"):
        full_text=f"{icon} {base_text}"+ (f" ({state_text})" if state_text else "")
        button.setText(full_text)
        style=f"""
            QPushButton {{
                background-color: {background_color}; color: {text_color};
                border: 1px solid #ccc; border-radius: 3px; padding: 6px;
                text-align: center;
            }}
            QPushButton:hover {{ background-color: #e8f0fe; }}
            QPushButton:pressed {{ background-color: #d0e0f8; }}
            QPushButton:disabled {{
                background-color: #f0f0f0; color: #a0a0a0; border-color: #d0d0d0;
            }} """
        button.setStyleSheet(style)

    def update_button_styles(self):
        is_ssim = self.current_comparison_method == METHOD_SSIM
        button_map = {
            REF_NORM: (self.SettingButton_Norm, self.CaptureButton_Norm, "·∫¢nh Norm", "Ch·ª•p Norm"),
            REF_SHUTDOWN: (self.SettingButton_Shutdown, self.CaptureButton_Shut, "·∫¢nh Shutdown", "Ch·ª•p Shutdown"),
            REF_FAIL: (self.SettingButton_Fail, self.CaptureButton_Fail, "·∫¢nh Fail", "Ch·ª•p Fail"),
        }
        icon_load="üìÇ"; icon_capture="üì∏"

        for key, (load_btn, cap_btn, load_txt, cap_txt) in button_map.items():
            has_image = isinstance(self.ref_data.get(key), np.ndarray) and self.ref_data[key].size > 0
            is_from_file = has_image and isinstance(self.config['ref_paths'].get(key), str)
            hint = "" if is_ssim else "(SSIM)"
            # ƒê·∫∑t tooltip r√µ r√†ng h∆°n
            ssim_tooltip = "Ch·ªâ d√πng cho ph∆∞∆°ng th·ª©c SSIM"
            load_tooltip = ssim_tooltip if not is_ssim else f"T·∫£i ·∫£nh tham chi·∫øu {key} t·ª´ file (cho SSIM)"
            cap_tooltip = ssim_tooltip if not is_ssim else f"Ch·ª•p ·∫£nh tham chi·∫øu {key} t·ª´ webcam (cho SSIM)"
            load_btn.setToolTip(load_tooltip)
            cap_btn.setToolTip(cap_tooltip)

            # ƒê·∫∑t style v√† m√†u n·ªÅn
            if has_image:
                if is_from_file: # ·∫¢nh t·ª´ file
                    self._set_button_style(load_btn, f"{load_txt} {hint}", icon_load, "File", "lightgreen" if is_ssim else "lightgray")
                    self._set_button_style(cap_btn, f"{cap_txt} {hint}", icon_capture)
                else: # ·∫¢nh t·ª´ webcam
                    self._set_button_style(load_btn, f"{load_txt} {hint}", icon_load)
                    self._set_button_style(cap_btn, f"{cap_txt} {hint}", icon_capture, "Webcam", "lightblue" if is_ssim else "lightgray")
            else: # Ch∆∞a c√≥ ·∫£nh
                 self._set_button_style(load_btn, f"{load_txt} {hint}", icon_load)
                 self._set_button_style(cap_btn, f"{cap_txt} {hint}", icon_capture)

        # N√∫t ROI v√† Th∆∞ m·ª•c l·ªói
        if self.webcam_roi: self._set_button_style(self.SettingButton_ROI_Webcam,"Ch·ªçn ROI","‚úÇÔ∏è","ƒê√£ ch·ªçn","lightblue")
        else: self._set_button_style(self.SettingButton_ROI_Webcam,"Ch·ªçn ROI","‚úÇÔ∏è")
        if self.error_folder: self._set_button_style(self.SaveButton,"Th∆∞ m·ª•c l·ªói","üìÅ","ƒê√£ ch·ªçn","lightblue")
        else: self._set_button_style(self.SaveButton,"Th∆∞ m·ª•c l·ªói","üìÅ")

    def update_toggle_button_text(self):
        if self.processing: self._set_button_style(self.ToggleProcessingButton,"D·ª´ng X·ª≠ l√Ω","‚èπ", background_color="orange")
        else: self._set_button_style(self.ToggleProcessingButton,"B·∫Øt ƒë·∫ßu","‚ñ∂Ô∏è", background_color="lightgreen")

    def update_record_button_style(self):
        if self._record_on_error_enabled: self._set_button_style(self.ToggleRecordOnErrorButton,"Quay video l·ªói","üé•","B·∫≠t","lightcoral")
        else: self._set_button_style(self.ToggleRecordOnErrorButton,"Quay video l·ªói","üé•","T·∫Øt","lightgray")

    def update_serial_button_style(self):
        if self.serial_enabled:
            self._set_button_style(self.ToggleSerialPortButton,"Ng·∫Øt k·∫øt n·ªëi COM","üîå","ƒêang k·∫øt n·ªëi","lightcoral")
        else:
            has_ports = hasattr(self,'comPortComboBox') and self.comPortComboBox.count() > 0 and "Kh√¥ng t√¨m th·∫•y" not in self.comPortComboBox.itemText(0)
            if has_ports: self._set_button_style(self.ToggleSerialPortButton,"K·∫øt n·ªëi COM","üîå","Ch∆∞a k·∫øt n·ªëi","lightgreen")
            else: self._set_button_style(self.ToggleSerialPortButton,"K·∫øt n·ªëi COM","üîå","Kh√¥ng c√≥ c·ªïng","lightgray")

    # --- start_webcam, update_frame, stop_webcam gi·ªØ nguy√™n ---
    def start_webcam(self):
        if self.cap is not None and self.cap.isOpened():
            self.log_activity("‚ö†Ô∏è Webcam ƒë√£ ƒë∆∞·ª£c b·∫≠t.")
            return
        try:
            # Th·ª≠ c√°c backend ph·ªï bi·∫øn tr√™n Windows tr∆∞·ªõc
            preferred_backends = [cv2.CAP_DSHOW, cv2.CAP_MSMF, None] # None = th·ª≠ backend m·∫∑c ƒë·ªãnh
            self.cap = None
            opened_backend = "N/A"

            for backend_flag in preferred_backends:
                api_preference = backend_flag if backend_flag is not None else cv2.CAP_ANY
                try:
                    temp_cap = cv2.VideoCapture(0, api_preference) # Index 0 l√† webcam m·∫∑c ƒë·ªãnh
                    if temp_cap and temp_cap.isOpened():
                        # Th·ª≠ ƒë·ªçc m·ªôt frame ƒë·ªÉ x√°c nh·∫≠n webcam ho·∫°t ƒë·ªông
                        ret_test, _ = temp_cap.read()
                        if ret_test:
                            self.cap = temp_cap # M·ªü th√†nh c√¥ng
                            opened_backend = self.cap.getBackendName()
                            break # Tho√°t v√≤ng l·∫∑p khi t√¨m ƒë∆∞·ª£c backend ho·∫°t ƒë·ªông
                        else:
                            temp_cap.release() # Backend m·ªü ƒë∆∞·ª£c nh∆∞ng kh√¥ng ƒë·ªçc ƒë∆∞·ª£c frame
                            self.log_activity(f"‚ÑπÔ∏è Webcam backend {api_preference} kh√¥ng ƒë·ªçc ƒë∆∞·ª£c frame.")
                    elif temp_cap: # temp_cap t·ªìn t·∫°i nh∆∞ng isOpened() l√† false
                        temp_cap.release()
                except Exception as cam_err:
                    # Ghi log l·ªói khi th·ª≠ backend c·ª• th·ªÉ
                    self.log_activity(f"‚ÑπÔ∏è L·ªói th·ª≠ webcam backend {api_preference}: {cam_err}")
                    if temp_cap: temp_cap.release()

            # Ki·ªÉm tra sau khi th·ª≠ t·∫•t c·∫£ c√°c backend
            if self.cap is None or not self.cap.isOpened():
                 raise IOError("Kh√¥ng th·ªÉ m·ªü webcam ho·∫∑c ƒë·ªçc frame ban ƒë·∫ßu.")

            # ƒê√£ m·ªü webcam th√†nh c√¥ng
            # L·∫•y th√¥ng tin webcam
            w = int(self.cap.get(cv2.CAP_PROP_FRAME_WIDTH))
            h = int(self.cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
            # C·ªë g·∫Øng ƒë·∫∑t FPS mong mu·ªën (kh√¥ng ph·∫£i l√∫c n√†o c≈©ng th√†nh c√¥ng)
            requested_fps = 15.0
            self.cap.set(cv2.CAP_PROP_FPS, requested_fps)
            actual_fps = self.cap.get(cv2.CAP_PROP_FPS)
            # N·∫øu kh√¥ng l·∫•y ƒë∆∞·ª£c FPS ho·∫∑c FPS=0, d√πng gi√° tr·ªã m·∫∑c ƒë·ªãnh
            if actual_fps <= 0: actual_fps = requested_fps
            self.webcam_fps = actual_fps
            # T√≠nh kho·∫£ng th·ªùi gian timer d·ª±a tr√™n FPS (ms), t·ªëi thi·ªÉu 33ms (~30fps)
            timer_interval = max(33, int(1000 / self.webcam_fps))

            self.log_activity(f"üöÄ Webcam ƒë√£ b·∫≠t (Backend: {opened_backend}, Res: {w}x{h}, FPS: {self.webcam_fps:.1f}, Interval: {timer_interval}ms)")

            # B·∫Øt ƒë·∫ßu timer ƒë·ªçc frame
            self.frame_timer.start(timer_interval)
            # C·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t
            self.ONCam.setEnabled(False); self.OFFCam.setEnabled(True)
            # ƒê·∫∑t n·ªÅn ƒëen cho khu v·ª±c hi·ªÉn th·ªã video
            self.graphicsView.setBackgroundBrush(QtGui.QBrush(Qt.black))

            # K√≠ch ho·∫°t c√°c n√∫t li√™n quan (Ch·ª•p ·∫£nh, ROI) n·∫øu kh√¥ng ƒëang x·ª≠ l√Ω
            if not self.processing:
                self.SettingButton_ROI_Webcam.setEnabled(True)
                # Ch·ªâ b·∫≠t n√∫t ch·ª•p n·∫øu ph∆∞∆°ng th·ª©c l√† SSIM (ho·∫∑c lu√¥n b·∫≠t n·∫øu mu·ªën?)
                is_ssim_mode = self.current_comparison_method == METHOD_SSIM
                for btn in [self.CaptureButton_Norm, self.CaptureButton_Shut, self.CaptureButton_Fail]:
                     btn.setEnabled(is_ssim_mode)

        except Exception as e:
            emsg = f"‚ùå L·ªói nghi√™m tr·ªçng khi b·∫≠t webcam: {e}"
            self.log_activity(emsg)
            self.log_activity(traceback.format_exc())
            QMessageBox.critical(self, "L·ªói Webcam", f"Kh√¥ng th·ªÉ kh·ªüi ƒë·ªông webcam.\nChi ti·∫øt: {e}")
            # ƒê·∫£m b·∫£o d·ªçn d·∫πp n·∫øu c√≥ l·ªói
            if self.cap: self.cap.release(); self.cap = None
            # Reset tr·∫°ng th√°i n√∫t
            self.ONCam.setEnabled(True); self.OFFCam.setEnabled(False)
            self.SettingButton_ROI_Webcam.setEnabled(False)
            for btn in [self.CaptureButton_Norm, self.CaptureButton_Shut, self.CaptureButton_Fail]: btn.setEnabled(False)
            self.graphicsView.setBackgroundBrush(QtGui.QBrush(Qt.darkGray))


    def update_frame(self):
        """ƒê·ªçc frame t·ª´ webcam, hi·ªÉn th·ªã v√† ƒë∆∞a v√†o queue x·ª≠ l√Ω."""
        if self.cap is None or not self.cap.isOpened(): return # Ch∆∞a c√≥ webcam

        ret, frame = self.cap.read() # ƒê·ªçc frame
        if not ret or frame is None:
            # Log l·ªói ƒë·ªçc frame ƒë·ªãnh k·ª≥ ƒë·ªÉ tr√°nh spam
            current_time = time.time()
            if not hasattr(self, 'last_read_error_time') or current_time - getattr(self, 'last_read_error_time', 0) > 5:
                self.log_activity("‚ö†Ô∏è L·ªói ƒë·ªçc frame t·ª´ webcam.")
                setattr(self, 'last_read_error_time', current_time)
            return

        # X√≥a c·ªù l·ªói n·∫øu ƒë·ªçc th√†nh c√¥ng
        if hasattr(self, 'last_read_error_time'): delattr(self, 'last_read_error_time')

        try:
            display_frame = frame.copy() # Frame ƒë·ªÉ hi·ªÉn th·ªã (c√≥ th·ªÉ v·∫Ω ROI)
            processing_frame = frame     # Frame ƒë·ªÉ x·ª≠ l√Ω (c√≥ th·ªÉ b·ªã crop)

            # 1. √Åp d·ª•ng ROI n·∫øu c√≥
            if self.webcam_roi:
                x, y, w, h = self.webcam_roi
                fh, fw = frame.shape[:2] # K√≠ch th∆∞·ªõc frame g·ªëc
                # ƒê·∫£m b·∫£o ROI n·∫±m trong khung h√¨nh
                x1, y1 = max(0, x), max(0, y)
                x2, y2 = min(fw, x + w), min(fh, y + h)
                if x2 > x1 and y2 > y1: # ROI h·ª£p l·ªá
                    # Crop frame ƒë·ªÉ x·ª≠ l√Ω
                    processing_frame = frame[y1:y2, x1:x2]
                    # V·∫Ω h√¨nh ch·ªØ nh·∫≠t ROI l√™n frame hi·ªÉn th·ªã
                    cv2.rectangle(display_frame, (x1, y1), (x2, y2), (0, 255, 0), 2)
                else: # ROI kh√¥ng h·ª£p l·ªá (v√≠ d·ª• ngo√†i khung h√¨nh)
                     processing_frame = frame # D√πng frame ƒë·∫ßy ƒë·ªß n·∫øu ROI l·ªói
                     # Log l·ªói ROI ƒë·ªãnh k·ª≥
                     current_time = time.time()
                     if not hasattr(self,'last_roi_error_time') or current_time - getattr(self,'last_roi_error_time', 0) > 10:
                         self.log_activity(f"‚ö†Ô∏è ROI {self.webcam_roi} kh√¥ng h·ª£p l·ªá. D√πng frame ƒë·∫ßy ƒë·ªß.")
                         setattr(self,'last_roi_error_time', current_time)
            else: # Kh√¥ng c√≥ ROI
                 if hasattr(self,'last_roi_error_time'): delattr(self,'last_roi_error_time')

            # 2. Hi·ªÉn th·ªã frame (display_frame)
            frame_rgb = cv2.cvtColor(display_frame, cv2.COLOR_BGR2RGB)
            h_disp, w_disp, ch = frame_rgb.shape
            bytes_per_line = ch * w_disp
            qt_image = QtGui.QImage(frame_rgb.data, w_disp, h_disp, bytes_per_line, QtGui.QImage.Format_RGB888)

            # Scale ·∫£nh ƒë·ªÉ v·ª´a v·ªõi QGraphicsView
            view_w = self.graphicsView.viewport().width()
            view_h = self.graphicsView.viewport().height()
            pixmap = QtGui.QPixmap.fromImage(qt_image).scaled(view_w - 2, view_h - 2, # Tr·ª´ vi·ªÅn 1px
                                                              Qt.KeepAspectRatio, Qt.SmoothTransformation)

            # C·∫≠p nh·∫≠t ho·∫∑c t·∫°o QGraphicsPixmapItem
            if self.pixmap_item is None:
                self.pixmap_item = QtWidgets.QGraphicsPixmapItem(pixmap)
                self.scene.addItem(self.pixmap_item)
                # CƒÉn gi·ªØa l·∫ßn ƒë·∫ßu
                self.graphicsView.fitInView(self.pixmap_item, Qt.KeepAspectRatio)
            else:
                self.pixmap_item.setPixmap(pixmap)
                # C·∫≠p nh·∫≠t l·∫°i view n·∫øu k√≠ch th∆∞·ªõc thay ƒë·ªïi (t√πy ch·ªçn)
                # self.graphicsView.fitInView(self.pixmap_item, Qt.KeepAspectRatio)


            # 3. X·ª≠ l√Ω ghi video (n·∫øu ƒëang b·∫≠t)
            if self.processing and self._record_on_error_enabled:
                # Kh·ªüi t·∫°o VideoWriter n·∫øu ch∆∞a c√≥
                if self.video_writer is None:
                    if self.error_folder and os.path.isdir(self.error_folder):
                        try:
                            vid_h, vid_w = processing_frame.shape[:2] # K√≠ch th∆∞·ªõc video b·∫±ng frame x·ª≠ l√Ω
                            video_dir = os.path.join(self.error_folder, VIDEO_SUBFOLDER)
                            os.makedirs(video_dir, exist_ok=True)
                            timestamp = time.strftime('%Y%m%d_%H%M%S')
                            video_filename = f"error_rec_{timestamp}.mp4" # Ho·∫∑c .avi
                            self.current_video_path = os.path.join(video_dir, video_filename)

                            # Ch·ªçn codec (mp4v cho .mp4, XVID cho .avi)
                            fourcc = cv2.VideoWriter_fourcc(*'mp4v') # Ho·∫∑c 'XVID'
                            # ƒê·∫£m b·∫£o FPS h·ª£p l·ªá
                            record_fps = max(1.0, self.webcam_fps) # √çt nh·∫•t 1 FPS
                            self.video_writer = cv2.VideoWriter(self.current_video_path, fourcc, record_fps, (vid_w, vid_h))

                            if self.video_writer.isOpened():
                                self.log_activity(f"üî¥ B·∫Øt ƒë·∫ßu ghi video l·ªói: {video_filename} ({vid_w}x{vid_h} @{record_fps:.1f}fps)")
                                self.error_occurred_during_recording = False # Reset c·ªù l·ªói
                            else:
                                self.log_activity(f"‚ùå Kh√¥ng th·ªÉ t·∫°o VideoWriter cho {video_filename}")
                                self.video_writer = None; self.current_video_path = None
                        except Exception as e_vid:
                            self.log_activity(f"‚ùå L·ªói t·∫°o VideoWriter: {e_vid}")
                            self.log_activity(traceback.format_exc())
                            self.video_writer = None; self.current_video_path = None
                    else: # Ch∆∞a c√≥ th∆∞ m·ª•c l·ªói
                         # Log c·∫£nh b√°o ƒë·ªãnh k·ª≥
                        current_time = time.time()
                        if not hasattr(self,'last_vid_folder_err') or current_time - getattr(self,'last_vid_folder_err', 0) > 30:
                            self.log_activity("‚ö†Ô∏è Ch∆∞a ƒë·∫∑t th∆∞ m·ª•c l·ªói h·ª£p l·ªá ƒë·ªÉ ghi video.")
                            setattr(self,'last_vid_folder_err', current_time)

                # Ghi frame v√†o video n·∫øu ƒë√£ m·ªü
                if self.video_writer and self.video_writer.isOpened():
                    try:
                        self.video_writer.write(processing_frame)
                    except Exception as e_write:
                        self.log_activity(f"‚ùå L·ªói ghi frame video: {e_write}")
                        # C√≥ th·ªÉ d·ª´ng ghi n·∫øu l·ªói li√™n t·ª•c?

            # 4. ƒê∆∞a frame v√†o queue cho worker (n·∫øu ƒëang x·ª≠ l√Ω)
            if self.processing:
                # T·∫°o b·∫£n sao frame ƒë·ªÉ g·ª≠i cho worker
                frame_to_process = processing_frame.copy()
                if not self.frame_queue.full():
                    try:
                        self.frame_queue.put(frame_to_process, block=False) # Non-blocking
                        if hasattr(self, 'last_queue_full_err'): delattr(self,'last_queue_full_err')
                    except Exception as q_put_err:
                         # Log l·ªói ƒë∆∞a v√†o queue (hi·∫øm)
                         current_time = time.time()
                         if not hasattr(self,'last_q_put_err') or current_time - getattr(self,'last_q_put_err', 0) > 5:
                            self.log_activity(f"‚ùå L·ªói ƒë∆∞a frame v√†o queue: {q_put_err}")
                            setattr(self,'last_q_put_err', current_time)
                else:
                    # Log l·ªói queue ƒë·∫ßy ƒë·ªãnh k·ª≥
                    current_time = time.time()
                    if not hasattr(self, 'last_queue_full_err') or current_time - getattr(self, 'last_queue_full_err', 0) > 5:
                         self.log_activity("‚ö†Ô∏è Queue x·ª≠ l√Ω ƒë·∫ßy, frame b·ªã b·ªè qua.")
                         setattr(self, 'last_queue_full_err', current_time)

        except Exception as e:
            # B·∫Øt l·ªói chung trong update_frame
            current_time = time.time()
            if not hasattr(self,'last_update_frame_err') or current_time - getattr(self,'last_update_frame_err', 0) > 5:
                 self.log_activity(f"‚ùå L·ªói trong update_frame: {e}")
                 self.log_activity(traceback.format_exc())
                 setattr(self,'last_update_frame_err', current_time)


    def stop_webcam(self):
        """D·ª´ng webcam v√† d·ªçn d·∫πp t√†i nguy√™n."""
        if self.cap and self.cap.isOpened():
            try:
                self.frame_timer.stop() # D·ª´ng timer tr∆∞·ªõc
                self.cap.release()
            except Exception as e:
                 self.log_activity(f"‚ö†Ô∏è L·ªói khi d·ª´ng webcam: {e}")
            finally:
                 self.cap = None
                 self.scene.clear()
                 self.pixmap_item = None
                 self.graphicsView.setBackgroundBrush(QtGui.QBrush(Qt.darkGray))
                 self.log_activity("üö´ Webcam ƒë√£ t·∫Øt.")
                 # C·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t
                 self.ONCam.setEnabled(True)
                 self.OFFCam.setEnabled(False)
                 self.SettingButton_ROI_Webcam.setEnabled(False)
                 # V√¥ hi·ªáu h√≥a n√∫t ch·ª•p ·∫£nh
                 for btn in [self.CaptureButton_Norm, self.CaptureButton_Shut, self.CaptureButton_Fail]:
                      btn.setEnabled(False)
                 # T·ª± ƒë·ªông d·ª´ng x·ª≠ l√Ω n·∫øu ƒëang ch·∫°y
                 if self.processing:
                     self.log_activity("‚ÑπÔ∏è T·ª± ƒë·ªông d·ª´ng x·ª≠ l√Ω do webcam t·∫Øt.")
                     self.toggle_processing() # G·ªçi h√†m d·ª´ng chu·∫©n
        elif self.cap is None:
            self.log_activity("‚ÑπÔ∏è Webcam ch∆∞a ƒë∆∞·ª£c b·∫≠t ƒë·ªÉ d·ª´ng.")
        # else: # Tr∆∞·ªùng h·ª£p self.cap t·ªìn t·∫°i nh∆∞ng not isOpened() (l·ªói tr∆∞·ªõc ƒë√≥)
        #     self.log_activity("‚ÑπÔ∏è Webcam ƒëang ·ªü tr·∫°ng th√°i l·ªói, b·ªè qua.")
        #     pass


    # --- load_reference_image, capture_reference_from_webcam gi·ªØ nguy√™n ---
    def load_reference_image(self, img_type):
        if self.processing:
             QMessageBox.warning(self, "ƒêang x·ª≠ l√Ω", "Kh√¥ng th·ªÉ thay ƒë·ªïi ·∫£nh tham chi·∫øu khi ƒëang x·ª≠ l√Ω.")
             return
        if self.current_comparison_method != METHOD_SSIM:
             # Ch·ªâ c·∫£nh b√°o, v·∫´n cho ph√©p t·∫£i
             QMessageBox.information(self, "Th√¥ng tin", f"·∫¢nh tham chi·∫øu hi·ªán ch·ªâ ƒë∆∞·ª£c s·ª≠ d·ª•ng cho ph∆∞∆°ng th·ª©c {METHOD_SSIM}.")

        opts=QFileDialog.Options()
        # Th∆∞ m·ª•c g·ª£i √Ω: th∆∞ m·ª•c ·∫£nh c≈© -> th∆∞ m·ª•c l·ªói -> home
        suggested_dir = os.path.expanduser("~") # M·∫∑c ƒë·ªãnh
        current_path = self.config['ref_paths'].get(img_type)
        if current_path and os.path.exists(os.path.dirname(current_path)):
            suggested_dir = os.path.dirname(current_path)
        elif self.error_folder and os.path.exists(self.error_folder):
            suggested_dir = self.error_folder

        fp, _ = QFileDialog.getOpenFileName(
            self, f"Ch·ªçn ·∫£nh tham chi·∫øu '{img_type}' (cho SSIM)", suggested_dir,
            "Images (*.png *.jpg *.jpeg *.bmp *.webp);;All Files (*)", options=opts)

        if fp:
            try:
                img_bytes = np.fromfile(fp, dtype=np.uint8)
                img = cv2.imdecode(img_bytes, cv2.IMREAD_COLOR)
                if img is None:
                    raise ValueError("Kh√¥ng th·ªÉ gi·∫£i m√£ file ·∫£nh ho·∫∑c ƒë·ªãnh d·∫°ng kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£.")

                # C·∫≠p nh·∫≠t d·ªØ li·ªáu v√† config
                self.ref_data[img_type] = img
                self.config['ref_paths'][img_type] = fp # L∆∞u ƒë∆∞·ªùng d·∫´n m·ªõi
                self.update_button_styles() # C·∫≠p nh·∫≠t UI n√∫t
                self.log_activity(f"‚úÖ ƒê√£ t·∫£i ·∫£nh '{img_type}' (SSIM) t·ª´: {os.path.basename(fp)}")
                # self.save_config() # C√≥ th·ªÉ kh√¥ng c·∫ßn l∆∞u ngay

            except Exception as e:
                self.log_activity(f"‚ùå L·ªói t·∫£i ·∫£nh {img_type} t·ª´ '{fp}': {e}")
                QMessageBox.warning(self, "L·ªói T·∫£i ·∫¢nh", f"Kh√¥ng th·ªÉ t·∫£i ·∫£nh:\n{fp}\n\nL·ªói: {e}")
                # X√≥a ƒë∆∞·ªùng d·∫´n n·∫øu t·∫£i l·ªói? (t√πy ch·ªçn)
                # self.config['ref_paths'][img_type] = None
                # self.ref_data[img_type] = None
                # self.update_button_styles()


    def capture_reference_from_webcam(self, img_type):
        if not self.cap or not self.cap.isOpened():
             QMessageBox.warning(self,"Webcam Ch∆∞a B·∫≠t","Vui l√≤ng b·∫≠t webcam tr∆∞·ªõc khi ch·ª•p.")
             return
        if self.processing:
             QMessageBox.warning(self,"ƒêang X·ª≠ L√Ω","Kh√¥ng th·ªÉ ch·ª•p ·∫£nh khi ƒëang x·ª≠ l√Ω.")
             return
        if self.current_comparison_method != METHOD_SSIM:
             QMessageBox.information(self, "Th√¥ng tin", f"Ch·ª•p ·∫£nh tham chi·∫øu hi·ªán ch·ªâ √°p d·ª•ng cho {METHOD_SSIM}.")
             # V·∫´n cho ph√©p ch·ª•p

        # T·∫°m d·ª´ng timer ƒë·ªçc frame ƒë·ªÉ l·∫•y ·∫£nh ·ªïn ƒë·ªãnh
        was_active = self.frame_timer.isActive()
        if was_active: self.frame_timer.stop(); time.sleep(0.1) # Ch·ªù ch√∫t

        ret, frame = self.cap.read() # ƒê·ªçc frame hi·ªán t·∫°i

        # Kh·ªüi ƒë·ªông l·∫°i timer n·∫øu c·∫ßn
        if was_active and self.cap and self.cap.isOpened():
            self.frame_timer.start()

        if not ret or frame is None:
            QMessageBox.warning(self,"L·ªói ƒê·ªçc Frame","Kh√¥ng th·ªÉ l·∫•y ·∫£nh t·ª´ webcam.")
            return

        try:
            # Quy·∫øt ƒë·ªãnh l∆∞u frame g·ªëc hay frame ƒë√£ crop ROI? Hi·ªán t·∫°i l∆∞u g·ªëc.
            frame_to_save = frame.copy()
            # L∆∞u ·∫£nh v√† c·∫≠p nh·∫≠t config
            self.ref_data[img_type] = frame_to_save
            self.config['ref_paths'][img_type] = None # ƒê√°nh d·∫•u l√† ch·ª•p t·ª´ webcam
            self.log_activity(f"üì∏ ƒê√£ ch·ª•p ·∫£nh '{img_type}' (SSIM) t·ª´ webcam.")
            self.update_button_styles() # C·∫≠p nh·∫≠t UI n√∫t
            # self.save_config()

        except Exception as e:
            self.log_activity(f"‚ùå L·ªói khi l∆∞u ·∫£nh ch·ª•p {img_type}: {e}")
            QMessageBox.critical(self,"L·ªói Ch·ª•p ·∫¢nh",f"ƒê√£ x·∫£y ra l·ªói: {e}")


    # --- select_webcam_roi, select_error_folder, serial functions gi·ªØ nguy√™n ---
    def select_webcam_roi(self):
        if not self.cap or not self.cap.isOpened():
            QMessageBox.warning(self, "Webcam Ch∆∞a B·∫≠t", "Vui l√≤ng b·∫≠t webcam tr∆∞·ªõc.")
            return
        if self.processing:
            QMessageBox.warning(self, "ƒêang X·ª≠ L√Ω", "Kh√¥ng th·ªÉ ch·ªçn ROI khi ƒëang x·ª≠ l√Ω.")
            return

        was_active = self.frame_timer.isActive()
        if was_active: self.frame_timer.stop(); time.sleep(0.1)
        ret, frame = self.cap.read()
        # Kh√¥ng b·∫≠t l·∫°i timer ngay ƒë·ªÉ c·ª≠a s·ªï ROI tƒ©nh

        if not ret or frame is None:
            if was_active and self.cap and self.cap.isOpened(): self.frame_timer.start() # B·∫≠t l·∫°i n·∫øu l·ªói ƒë·ªçc
            QMessageBox.warning(self, "L·ªói ƒê·ªçc Frame", "Kh√¥ng th·ªÉ l·∫•y ·∫£nh ƒë·ªÉ ch·ªçn ROI.")
            return

        try:
            # ƒê·∫∑t t√™n c·ª≠a s·ªï d·ªÖ hi·ªÉu
            window_name = "Chon ROI - Keo chuot roi Enter/Space (C/ESC=Huy, R=Reset)"
            cv2.namedWindow(window_name, cv2.WINDOW_NORMAL) # Cho ph√©p resize c·ª≠a s·ªï
            cv2.resizeWindow(window_name, 800, 600) # K√≠ch th∆∞·ªõc c·ª≠a s·ªï ban ƒë·∫ßu
            cv2.setWindowTitle(window_name, window_name)

            # V·∫Ω h∆∞·ªõng d·∫´n l√™n ·∫£nh (t√πy ch·ªçn)
            frame_roi_select = frame.copy()
            # ... (c√≥ th·ªÉ th√™m cv2.putText h∆∞·ªõng d·∫´n) ...

            # Hi·ªÉn th·ªã c·ª≠a s·ªï ch·ªçn ROI c·ªßa OpenCV
            roi = cv2.selectROI(window_name, frame_roi_select, showCrosshair=True, fromCenter=False)
            cv2.destroyWindow(window_name) # ƒê√≥ng c·ª≠a s·ªï ch·ªçn ROI

            # B·∫≠t l·∫°i timer webcam sau khi ƒë√≥ng c·ª≠a s·ªï ch·ªçn
            if was_active and self.cap and self.cap.isOpened():
                self.frame_timer.start()

            # X·ª≠ l√Ω k·∫øt qu·∫£ tr·∫£ v·ªÅ t·ª´ selectROI
            if roi == (0, 0, 0, 0): # Ng∆∞·ªùi d√πng h·ªßy (nh·∫•n ESC/C ho·∫∑c ƒë√≥ng c·ª≠a s·ªï)
                self.log_activity("‚ÑπÔ∏è ƒê√£ h·ªßy ch·ªçn ROI.")
                return

            # Ki·ªÉm tra ROI h·ª£p l·ªá (w > 0 v√† h > 0)
            if roi[2] > 0 and roi[3] > 0:
                # Chuy·ªÉn sang tuple s·ªë nguy√™n kh√¥ng √¢m
                self.webcam_roi = tuple(max(0, int(v)) for v in roi)
                self.config['webcam_roi'] = list(self.webcam_roi) # L∆∞u v√†o config
                self.log_activity(f"‚úÖ ƒê√£ ch·ªçn ROI m·ªõi: {self.webcam_roi}")
                # self.save_config() # L∆∞u config
            else:
                self.log_activity("‚ö†Ô∏è ROI kh√¥ng h·ª£p l·ªá (w=0 ho·∫∑c h=0), kh√¥ng √°p d·ª•ng.")
                self.webcam_roi = None # Reset ROI n·∫øu kh√¥ng h·ª£p l·ªá
                self.config['webcam_roi'] = None

            # C·∫≠p nh·∫≠t style n√∫t ROI
            self.update_button_styles()

        except Exception as e:
            self.log_activity(f"‚ùå L·ªói trong qu√° tr√¨nh ch·ªçn ROI: {e}")
            self.log_activity(traceback.format_exc())
            QMessageBox.critical(self, "L·ªói Ch·ªçn ROI", f"ƒê√£ x·∫£y ra l·ªói:\n{e}")
            cv2.destroyAllWindows() # ƒê·∫£m b·∫£o ƒë√≥ng m·ªçi c·ª≠a s·ªï OpenCV n·∫øu l·ªói
            # B·∫≠t l·∫°i timer n·∫øu c·∫ßn v√† ch∆∞a b·∫≠t
            if was_active and self.cap and self.cap.isOpened() and not self.frame_timer.isActive():
                self.frame_timer.start()

    def select_error_folder(self):
        if self.processing:
            QMessageBox.warning(self, "ƒêang X·ª≠ L√Ω", "Kh√¥ng th·ªÉ thay ƒë·ªïi th∆∞ m·ª•c khi ƒëang x·ª≠ l√Ω.")
            return

        opts = QFileDialog.Options() | QFileDialog.ShowDirsOnly
        # Th∆∞ m·ª•c g·ª£i √Ω: th∆∞ m·ª•c c≈© ho·∫∑c th∆∞ m·ª•c home
        suggested_dir = self.error_folder or os.path.expanduser("~")

        folder = QFileDialog.getExistingDirectory(
            self, "Ch·ªçn th∆∞ m·ª•c l∆∞u ·∫£nh l·ªói, video v√† log", suggested_dir, opts)

        if folder: # N·∫øu ng∆∞·ªùi d√πng ƒë√£ ch·ªçn
            # Ki·ªÉm tra quy·ªÅn ghi
            if not os.access(folder, os.W_OK):
                QMessageBox.warning(self, "Kh√¥ng C√≥ Quy·ªÅn Ghi",
                                  f"Kh√¥ng th·ªÉ ghi v√†o th∆∞ m·ª•c:\n{folder}\n\nVui l√≤ng ch·ªçn th∆∞ m·ª•c kh√°c ho·∫∑c ki·ªÉm tra quy·ªÅn.")
                return

            # Ch·ªâ c·∫≠p nh·∫≠t n·∫øu th∆∞ m·ª•c th·ª±c s·ª± thay ƒë·ªïi
            if self.error_folder != folder:
                self.error_folder = folder
                self.config['error_folder'] = folder
                self.log_activity(f"üìÅ ƒê√£ ch·ªçn th∆∞ m·ª•c l·ªói: {self.error_folder}")
                # C·∫≠p nh·∫≠t ƒë∆∞·ªùng d·∫´n file log
                self.log_file_path = os.path.join(self.error_folder, LOG_FILE_NAME)
                self.log_activity(f"üìÑ File log s·∫Ω ghi t·∫°i: {self.log_file_path}")
                # Ghi th·ª≠ v√†o log m·ªõi (t√πy ch·ªçn)
                self.log_activity("üìù (Th·ª≠ ghi log v√†o th∆∞ m·ª•c m·ªõi)")
                # self.save_config() # L∆∞u c·∫•u h√¨nh
                self.update_button_styles() # C·∫≠p nh·∫≠t style n√∫t

    @QtCore.pyqtSlot()
    def _refresh_com_ports(self):
        if self.serial_enabled:
            self.log_activity("‚ÑπÔ∏è Ng·∫Øt k·∫øt n·ªëi COM tr∆∞·ªõc khi l√†m m·ªõi danh s√°ch.")
            return

        self.comPortComboBox.blockSignals(True)
        current_selection = self.comPortComboBox.currentText()
        self.comPortComboBox.clear()
        port_names = []
        try:
            ports = serial.tools.list_ports.comports()
            port_names = sorted([port.device for port in ports])
            if port_names: self.log_activity(f"üîÑ COM ports found: {', '.join(port_names)}")
            else: self.log_activity("üîÑ No COM ports found.")
        except Exception as e:
            self.log_activity(f"‚ùå L·ªói li·ªát k√™ c·ªïng COM: {e}")

        if not port_names:
             self.comPortComboBox.addItem("Kh√¥ng t√¨m th·∫•y c·ªïng")
             self.comPortComboBox.setEnabled(False)
             self.serial_port_name = None
        else:
            self.comPortComboBox.addItems(port_names)
            self.comPortComboBox.setEnabled(True)
            if current_selection in port_names:
                 self.comPortComboBox.setCurrentText(current_selection)
                 self.serial_port_name = current_selection
            else: # Ch·ªçn c·ªïng ƒë·∫ßu ti√™n n·∫øu c·ªïng c≈© kh√¥ng c√≤n
                 self.comPortComboBox.setCurrentIndex(0)
                 new_selection = self.comPortComboBox.currentText()
                 if current_selection and "Kh√¥ng t√¨m th·∫•y" not in current_selection:
                     self.log_activity(f"‚ö†Ô∏è COM '{current_selection}' kh√¥ng c√≤n. Ch·ªçn '{new_selection}'.")
                 self.serial_port_name = new_selection # C·∫≠p nh·∫≠t state

        # C·∫≠p nh·∫≠t config v√† UI
        self.config['serial_port'] = self.serial_port_name
        self.comPortComboBox.blockSignals(False)
        self.update_serial_button_style()
        # B·∫≠t/t·∫Øt combobox Baudrate d·ª±a tr√™n vi·ªác c√≥ c·ªïng hay kh√¥ng
        self.baudRateComboBox.setEnabled(bool(port_names))

    @QtCore.pyqtSlot()
    def _toggle_serial_port(self):
        if self.processing:
            QMessageBox.warning(self, "ƒêang X·ª≠ L√Ω", "Kh√¥ng th·ªÉ thay ƒë·ªïi k·∫øt n·ªëi COM khi ƒëang x·ª≠ l√Ω.")
            return

        if not self.serial_enabled: # --- Logic K·∫æT N·ªêI ---
            port = self.comPortComboBox.currentText()
            baud = self.serial_baud_rate
            if not port or "Kh√¥ng t√¨m th·∫•y" in port:
                QMessageBox.warning(self, "Ch∆∞a Ch·ªçn C·ªïng", "Vui l√≤ng ch·ªçn c·ªïng COM h·ª£p l·ªá.")
                return

            # ƒê√≥ng c·ªïng c≈© (n·∫øu c√≥) tr∆∞·ªõc khi m·ªü c·ªïng m·ªõi
            if self.serial_port and self.serial_port.is_open:
                try: self.serial_port.close()
                except Exception: pass

            try:
                self.log_activity(f"üîå ƒêang k·∫øt n·ªëi {port} @ {baud} baud...")
                # Th√™m timeout khi ghi ƒë·ªÉ tr√°nh treo
                self.serial_port = serial.Serial(port, baud, timeout=0.1, write_timeout=1.0)
                # ---- K·∫øt n·ªëi th√†nh c√¥ng ----
                self.serial_enabled = True
                self.serial_port_name = port # C·∫≠p nh·∫≠t t√™n c·ªïng th·ª±c t·∫ø
                self.config['serial_enabled'] = True # L∆∞u tr·∫°ng th√°i (d√π s·∫Ω reset khi t·∫£i)
                self.config['serial_port'] = port
                self.config['serial_baud'] = baud
                self.log_activity(f"‚úÖ ƒê√£ k·∫øt n·ªëi COM: {port}")
                # V√¥ hi·ªáu h√≥a c·∫•u h√¨nh COM khi ƒëang k·∫øt n·ªëi
                self.comPortComboBox.setEnabled(False)
                self.baudRateComboBox.setEnabled(False)
                self.refreshComButton.setEnabled(False)

            except serial.SerialException as e:
                self.log_activity(f"‚ùå L·ªói m·ªü c·ªïng COM '{port}': {e}")
                QMessageBox.critical(self, "L·ªói K·∫øt N·ªëi COM", f"Kh√¥ng th·ªÉ m·ªü c·ªïng {port}.\nL·ªói: {e}\nKi·ªÉm tra driver ho·∫∑c c·ªïng c√≥ ƒëang b·ªã d√πng b·ªüi ch∆∞∆°ng tr√¨nh kh√°c?")
                self.serial_port = None; self.serial_enabled = False
                self.config['serial_enabled'] = False
                # Cho ph√©p c·∫•u h√¨nh l·∫°i n·∫øu l·ªói
                has_ports = self.comPortComboBox.count() > 0 and "Kh√¥ng t√¨m th·∫•y" not in self.comPortComboBox.itemText(0)
                self.comPortComboBox.setEnabled(has_ports)
                self.baudRateComboBox.setEnabled(has_ports)
                self.refreshComButton.setEnabled(True)
            except Exception as e_unk: # L·ªói kh√¥ng x√°c ƒë·ªãnh kh√°c
                self.log_activity(f"‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh khi m·ªü COM '{port}': {e_unk}")
                self.log_activity(traceback.format_exc())
                QMessageBox.critical(self, "L·ªói Nghi√™m Tr·ªçng", f"L·ªói kh√¥ng mong mu·ªën khi k·∫øt n·ªëi COM.\nL·ªói: {e_unk}")
                self.serial_port = None; self.serial_enabled = False
                self.config['serial_enabled'] = False
                has_ports = self.comPortComboBox.count() > 0 and "Kh√¥ng t√¨m th·∫•y" not in self.comPortComboBox.itemText(0)
                self.comPortComboBox.setEnabled(has_ports); self.baudRateComboBox.setEnabled(has_ports); self.refreshComButton.setEnabled(True)

        else: # --- Logic NG·∫ÆT K·∫æT N·ªêI ---
            port_to_close = self.serial_port_name or "N/A"
            try:
                if self.serial_port and self.serial_port.is_open:
                    self.log_activity(f"üîå ƒêang ng·∫Øt k·∫øt n·ªëi COM: {port_to_close}...")
                    self.serial_port.close()
                    self.log_activity(f"üîå ƒê√£ ng·∫Øt k·∫øt n·ªëi COM.")
            except serial.SerialException as e:
                 self.log_activity(f"‚ö†Ô∏è L·ªói khi ƒë√≥ng c·ªïng COM '{port_to_close}': {e}")
            except Exception as e_unk:
                 self.log_activity(f"‚ö†Ô∏è L·ªói kh√¥ng x√°c ƒë·ªãnh khi ƒë√≥ng COM '{port_to_close}': {e_unk}")
            finally:
                 # Lu√¥n d·ªçn d·∫πp v√† c·∫≠p nh·∫≠t UI/state
                 self.serial_port = None
                 self.serial_enabled = False
                 self.config['serial_enabled'] = False
                 # B·∫≠t l·∫°i c√°c control c·∫•u h√¨nh COM
                 has_ports = self.comPortComboBox.count() > 0 and "Kh√¥ng t√¨m th·∫•y" not in self.comPortComboBox.itemText(0)
                 self.comPortComboBox.setEnabled(has_ports)
                 self.baudRateComboBox.setEnabled(has_ports)
                 self.refreshComButton.setEnabled(True)

        # C·∫≠p nh·∫≠t style n√∫t Connect/Disconnect
        self.update_serial_button_style()
        # self.save_config() # L∆∞u tr·∫°ng th√°i m·ªõi

    @QtCore.pyqtSlot(str)
    def _send_serial_command(self, command):
        """G·ª≠i l·ªánh (chu·ªói) qua c·ªïng serial ƒë√£ m·ªü."""
        if self.serial_enabled and self.serial_port and self.serial_port.is_open:
            try:
                # ƒê·∫£m b·∫£o l·ªánh k·∫øt th√∫c b·∫±ng newline
                cmd_with_newline = command if command.endswith('\n') else command + '\n'
                byte_command = cmd_with_newline.encode('utf-8') # Chuy·ªÉn sang bytes
                bytes_written = self.serial_port.write(byte_command)
                # C√≥ th·ªÉ c·∫ßn flush ƒë·ªÉ ƒë·∫£m b·∫£o g·ª≠i ngay l·∫≠p t·ª©c
                # self.serial_port.flush()
                if bytes_written == len(byte_command):
                     # Log th√†nh c√¥ng (c√≥ th·ªÉ gi·∫£m b·ªõt n·∫øu qu√° nhi·ªÅu)
                     # self.log_activity(f"‚û°Ô∏è G·ª≠i COM [{self.serial_port_name}]: {command}")
                     pass
                else: # Ghi kh√¥ng ƒë·ªß byte (hi·∫øm khi x·∫£y ra v·ªõi write_timeout)
                     self.log_activity(f"‚ö†Ô∏è G·ª≠i COM [{self.serial_port_name}] kh√¥ng ƒë·ªß byte: {command} ({bytes_written}/{len(byte_command)} bytes)")

            except serial.SerialTimeoutException: # L·ªói timeout khi ghi
                self.log_activity(f"‚ö†Ô∏è Timeout khi g·ª≠i l·ªánh COM t·ªõi '{self.serial_port_name}'.")
                # C√¢n nh·∫Øc t·ª± ƒë·ªông ng·∫Øt k·∫øt n·ªëi n·∫øu l·ªói n√†y l·∫∑p l·∫°i?
            except serial.SerialException as e: # L·ªói serial kh√°c khi ghi
                self.log_activity(f"‚ùå L·ªói nghi√™m tr·ªçng khi g·ª≠i l·ªánh COM: {e}. T·ª± ƒë·ªông ng·∫Øt k·∫øt n·ªëi.")
                QMessageBox.critical(self, "L·ªói G·ª≠i COM", f"Kh√¥ng th·ªÉ g·ª≠i d·ªØ li·ªáu t·ªõi {self.serial_port_name}.\nK·∫øt n·ªëi s·∫Ω b·ªã ƒë√≥ng.\nL·ªói: {e}")
                self._toggle_serial_port() # G·ªçi h√†m ng·∫Øt k·∫øt n·ªëi
            except Exception as e_unk: # L·ªói kh√¥ng x√°c ƒë·ªãnh
                 self.log_activity(f"‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh khi g·ª≠i l·ªánh COM: {e_unk}. Ng·∫Øt k·∫øt n·ªëi.")
                 self.log_activity(traceback.format_exc())
                 QMessageBox.critical(self, "L·ªói G·ª≠i COM", f"L·ªói kh√¥ng mong mu·ªën khi g·ª≠i d·ªØ li·ªáu.\nK·∫øt n·ªëi s·∫Ω b·ªã ƒë√≥ng.\nL·ªói: {e_unk}")
                 self._toggle_serial_port()


    # --- _select_yolo_model_path, _load_yolo_model gi·ªØ nguy√™n ---
    @QtCore.pyqtSlot()
    def _select_yolo_model_path(self):
        """M·ªü dialog cho ph√©p ng∆∞·ªùi d√πng ch·ªçn file model YOLO .pt."""
        if self.processing:
             QMessageBox.warning(self, "ƒêang X·ª≠ L√Ω", "Kh√¥ng th·ªÉ thay ƒë·ªïi model khi ƒëang x·ª≠ l√Ω.")
             return
        opts = QFileDialog.Options()
        # Th∆∞ m·ª•c g·ª£i √Ω: th∆∞ m·ª•c model c≈© ho·∫∑c th∆∞ m·ª•c home
        current_path = self.config.get('yolo_model_path')
        suggested_dir = os.path.dirname(current_path) if current_path and os.path.isdir(os.path.dirname(current_path)) else os.path.expanduser("~")

        fp, _ = QFileDialog.getOpenFileName(self, "Ch·ªçn Model YOLOv8 (.pt)", suggested_dir,
                                            "PyTorch Models (*.pt);;All Files (*)", options=opts)
        if fp:
            # Ch·ªâ x·ª≠ l√Ω n·∫øu ƒë∆∞·ªùng d·∫´n th·ª±c s·ª± thay ƒë·ªïi
            if self.config.get('yolo_model_path') != fp:
                self.config['yolo_model_path'] = fp
                self.log_activity(f"üìÅ Ch·ªçn model YOLO m·ªõi: {os.path.basename(fp)}")
                # C·∫≠p nh·∫≠t label hi·ªÉn th·ªã ƒë∆∞·ªùng d·∫´n
                self.yoloModelPathLabel.setText(os.path.basename(fp))
                self.yoloModelPathLabel.setStyleSheet("font-style: normal; color: black;") # B·ªè italic
                self.yoloModelPathLabel.setToolTip(fp) # ƒê·∫∑t tooltip l√† ƒë∆∞·ªùng d·∫´n ƒë·∫ßy ƒë·ªß

                # Gi·∫£i ph√≥ng model c≈© v√† th·ª≠ t·∫£i model m·ªõi
                if self.yolo_model is not None:
                    del self.yolo_model; self.yolo_model = None
                    # C√≥ th·ªÉ th√™m cleanup GPU n·∫øu c·∫ßn: if torch: torch.cuda.empty_cache()
                    self.log_activity("üß† ƒê√£ gi·∫£i ph√≥ng model YOLO c≈©.")

                self._load_yolo_model() # Th·ª≠ t·∫£i model m·ªõi ngay l·∫≠p t·ª©c
                # self.save_config() # L∆∞u config (t√πy ch·ªçn, c√≥ th·ªÉ ƒë·ª£i)

    def _load_yolo_model(self):
        """T·∫£i model YOLO t·ª´ ƒë∆∞·ªùng d·∫´n trong config. Tr·∫£ v·ªÅ True n·∫øu th√†nh c√¥ng."""
        if not YOLO_AVAILABLE:
            # self.log_activity("‚ö†Ô∏è Th∆∞ vi·ªán YOLOv8 ch∆∞a c√†i ƒë·∫∑t.") # ƒê√£ log ·ªü init
            return False

        model_path = self.config.get('yolo_model_path')
        if not model_path or not isinstance(model_path, str):
            self.log_activity("‚ö†Ô∏è Ch∆∞a c·∫•u h√¨nh ƒë∆∞·ªùng d·∫´n model YOLO.")
            return False

        # Ki·ªÉm tra n·∫øu model ƒë√£ t·∫£i v√† c√πng ƒë∆∞·ªùng d·∫´n -> kh√¥ng c·∫ßn t·∫£i l·∫°i
        if self.yolo_model and hasattr(self.yolo_model, 'ckpt_path') and self.yolo_model.ckpt_path == model_path:
             # self.log_activity("‚ÑπÔ∏è Model YOLO ƒë√£ ƒë∆∞·ª£c t·∫£i (kh√¥ng ƒë·ªïi).")
             return True # ƒê√£ t·∫£i ƒë√∫ng model

        # N·∫øu c√≥ model c≈© kh√°c, gi·∫£i ph√≥ng tr∆∞·ªõc
        if self.yolo_model is not None:
            self.log_activity("üß† Gi·∫£i ph√≥ng model YOLO c≈©...")
            del self.yolo_model; self.yolo_model = None
            # if torch and torch.cuda.is_available(): torch.cuda.empty_cache()

        # B·∫Øt ƒë·∫ßu t·∫£i model m·ªõi
        self.log_activity(f"‚è≥ ƒêang t·∫£i model YOLO: {os.path.basename(model_path)}...")
        # C·∫≠p nh·∫≠t UI ƒë·ªÉ b√°o ƒëang t·∫£i
        self.details_label.setText("Details: ƒêang t·∫£i model YOLO...")
        QtWidgets.QApplication.processEvents() # Bu·ªôc c·∫≠p nh·∫≠t UI ngay

        try:
            # === T·∫¢I MODEL ===
            self.yolo_model = YOLO(model_path) # C√≥ th·ªÉ m·∫•t th·ªùi gian / treo UI!
            # === T·∫¢I XONG ===

            # T√πy ch·ªçn: Ch·∫°y th·ª≠ m·ªôt d·ª± ƒëo√°n nh·ªè ƒë·ªÉ "warm-up" model
            # try:
            #     dummy_img = np.zeros((64, 64, 3), dtype=np.uint8)
            #     self.yolo_model.predict(dummy_img, verbose=False)
            # except Exception as wu_err:
            #     self.log_activity(f"‚ö†Ô∏è L·ªói khi warm-up model: {wu_err}") # Kh√¥ng nghi√™m tr·ªçng

            self.log_activity(f"‚úÖ Model YOLO '{os.path.basename(model_path)}' ƒë√£ t·∫£i.")
            self.details_label.setText("Details: Model YOLO ƒë√£ t·∫£i.") # C·∫≠p nh·∫≠t UI
            return True # Tr·∫£ v·ªÅ True khi th√†nh c√¥ng

        except Exception as e:
            # L·ªói nghi√™m tr·ªçng khi t·∫£i model
            load_error_msg = f"Kh√¥ng th·ªÉ t·∫£i model:\n{model_path}\n\nL·ªói: {e}"
            self.log_activity(f"‚ùå L·ªói nghi√™m tr·ªçng t·∫£i model YOLO: {e}")
            self.log_activity(traceback.format_exc()) # Ghi traceback ƒë·ªÉ debug
            QMessageBox.critical(self, "L·ªói T·∫£i Model YOLO", load_error_msg)
            # ƒê·∫£m b·∫£o model l√† None n·∫øu l·ªói
            self.yolo_model = None
            # C·∫≠p nh·∫≠t UI b√°o l·ªói
            self.details_label.setText("Details: L·ªói t·∫£i model YOLO.")
            # Reset ƒë∆∞·ªùng d·∫´n trong UI v√† config n·∫øu t·∫£i l·ªói?
            self.config['yolo_model_path'] = None
            self.yoloModelPathLabel.setText("L·ªói t·∫£i model!")
            self.yoloModelPathLabel.setStyleSheet("font-style: italic; color: red;")
            self.yoloModelPathLabel.setToolTip("")
            return False # Tr·∫£ v·ªÅ False khi th·∫•t b·∫°i


    # --- toggle_processing, _mark_error_occurred, disable_settings_while_processing,
    #      _runtime_timer_timeout gi·ªØ nguy√™n ---
    def toggle_processing(self):
        # --- Ki·ªÉm tra ƒëi·ªÅu ki·ªán tr∆∞·ªõc khi B·∫ÆT ƒê·∫¶U ---
        if not self.processing:
            # Ki·ªÉm tra theo ph∆∞∆°ng th·ª©c
            if self.current_comparison_method == METHOD_SSIM:
                if not isinstance(self.ref_data.get(REF_NORM), np.ndarray) or self.ref_data[REF_NORM].size == 0:
                    QMessageBox.warning(self, "Thi·∫øu ·∫¢nh Tham Chi·∫øu", f"Vui l√≤ng t·∫£i/ch·ª•p ·∫£nh '{REF_NORM}' (cho SSIM) tr∆∞·ªõc.")
                    return
            elif self.current_comparison_method == METHOD_YOLO:
                if not self.yolo_model: # Model ch∆∞a ƒë∆∞·ª£c t·∫£i?
                    if not self.config.get('yolo_model_path'):
                         QMessageBox.warning(self, "Thi·∫øu Model YOLO", "Vui l√≤ng ch·ªçn ƒë∆∞·ªùng d·∫´n model YOLO trong c·∫•u h√¨nh.")
                         return
                    else:
                         # ƒê√£ c√≥ ƒë∆∞·ªùng d·∫´n nh∆∞ng model ch∆∞a t·∫£i (c√≥ th·ªÉ do l·ªói tr∆∞·ªõc ƒë√≥) -> Th·ª≠ t·∫£i l·∫°i
                         self.log_activity("‚ÑπÔ∏è Model YOLO ch∆∞a t·∫£i, ƒëang th·ª≠ t·∫£i l·∫°i...")
                         if not self._load_yolo_model(): # N·∫øu t·∫£i l·∫°i v·∫´n l·ªói
                              QMessageBox.warning(self, "L·ªói T·∫£i Model", "Kh√¥ng th·ªÉ t·∫£i model YOLO. Vui l√≤ng ki·ªÉm tra ƒë∆∞·ªùng d·∫´n v√† file.")
                              return
                         # N·∫øu t·∫£i l·∫°i th√†nh c√¥ng, ti·∫øp t·ª•c
                # Th√™m ki·ªÉm tra quy t·∫Øc YOLO n·∫øu c·∫ßn (v√≠ d·ª•: ƒë√£ ƒë·ªãnh nghƒ©a ch∆∞a?)
            # Ki·ªÉm tra chung
            if not self.error_folder or not os.path.isdir(self.error_folder) or not os.access(self.error_folder, os.W_OK):
                 QMessageBox.warning(self, "Thi·∫øu Th∆∞ M·ª•c L·ªói", "Vui l√≤ng ch·ªçn th∆∞ m·ª•c h·ª£p l·ªá (c√≥ quy·ªÅn ghi) ƒë·ªÉ l∆∞u l·ªói/log/video.")
                 return
            if not self.cap or not self.cap.isOpened():
                 QMessageBox.warning(self, "Webcam Ch∆∞a B·∫≠t", "Vui l√≤ng b·∫≠t webcam tr∆∞·ªõc.")
                 return

        # --- Chuy·ªÉn ƒë·ªïi tr·∫°ng th√°i processing ---
        self.processing = not self.processing

        if self.processing: # --- Logic B·∫ÆT ƒê·∫¶U ---
            self.log_activity(f"‚ñ∂Ô∏è B·∫Øt ƒë·∫ßu x·ª≠ l√Ω (Ph∆∞∆°ng th·ª©c: {self.current_comparison_method})...")
            self.save_config() # L∆∞u c·∫•u h√¨nh hi·ªán t·∫°i tr∆∞·ªõc khi ch·∫°y

            # L·∫•y h√†m so s√°nh t∆∞∆°ng ·ª©ng
            compare_func = self.comparison_functions.get(self.current_comparison_method)
            if not compare_func:
                self.log_activity(f"‚ùå L·ªói nghi√™m tr·ªçng: Kh√¥ng t√¨m th·∫•y h√†m x·ª≠ l√Ω cho ph∆∞∆°ng th·ª©c '{self.current_comparison_method}'.")
                self.processing = False # H·ªßy b·∫Øt ƒë·∫ßu
                self.update_toggle_button_text() # C·∫≠p nh·∫≠t l·∫°i n√∫t Start
                return

            # D·ªçn d·∫πp worker c≈© (n·∫øu c√≥)
            if self.processing_worker and self.processing_worker.isRunning():
                self.log_activity("‚öôÔ∏è D·ª´ng worker c≈©...")
                self.processing_worker.stop()
                if not self.processing_worker.wait(1500): # Ch·ªù t·ªëi ƒëa 1.5s
                    self.log_activity("‚ö†Ô∏è Worker c≈© kh√¥ng d·ª´ng k·ªãp th·ªùi!")
                # Ng·∫Øt k·∫øt n·ªëi t√≠n hi·ªáu c≈©? Th∆∞·ªùng kh√¥ng c·∫ßn n·∫øu ƒë·ªëi t∆∞·ª£ng b·ªã x√≥a
                # try: self.processing_worker.signals_disconnected.disconnect() # V√≠ d·ª•
                # except TypeError: pass

            # D·ªçn s·∫°ch frame c≈© trong queue
            cleared_count = 0
            while not self.frame_queue.empty():
                try: self.frame_queue.get_nowait(); cleared_count += 1
                except Empty: break
            if cleared_count > 0: self.log_activity(f"‚ÑπÔ∏è ƒê√£ d·ªçn {cleared_count} frame c≈©.")

            # T·∫°o v√† kh·ªüi ch·∫°y worker M·ªöI
            self.processing_worker = ProcessingWorker(
                self.frame_queue,
                self.get_reference_data_for_worker, # Cung c·∫•p data ph√π h·ª£p (·∫£nh/rules)
                self.get_current_config_for_worker, # Cung c·∫•p config c·∫ßn thi·∫øt
                compare_func                     # Truy·ªÅn h√†m so s√°nh c·ª• th·ªÉ
            )
            # K·∫øt n·ªëi t√≠n hi·ªáu t·ª´ worker m·ªõi ƒë·∫øn c√°c slot c·ªßa Main thread
            self.processing_worker.log_signal.connect(self.log_activity)
            self.processing_worker.status_signal.connect(self.update_status_label)
            self.processing_worker.save_error_signal.connect(self.save_error_image_from_thread)
            self.processing_worker.comparison_details_signal.connect(self.update_details_display)
            self.processing_worker.error_detected_signal.connect(self._mark_error_occurred)
            self.processing_worker.serial_command_signal.connect(self._send_serial_command)

            # B·∫Øt ƒë·∫ßu worker
            self.processing_worker.last_error_time = 0 # Reset cooldown
            self.processing_worker.start()

            # C·∫≠p nh·∫≠t UI tr·∫°ng th√°i b·∫Øt ƒë·∫ßu
            self.update_status_label(ComparisonStatus.UNKNOWN, {"status": "Starting..."}) # Tr·∫°ng th√°i kh·ªüi t·∫°o

            # B·∫Øt ƒë·∫ßu timer h·∫πn gi·ªù ch·∫°y (n·∫øu c√≥ c·∫•u h√¨nh)
            if self._current_runtime_minutes > 0:
                duration_ms = self._current_runtime_minutes * 60 * 1000
                self.runtime_timer.start(duration_ms)
                self.log_activity(f"‚è±Ô∏è H·∫πn gi·ªù t·ª± ƒë·ªông d·ª´ng sau {self._current_runtime_minutes} ph√∫t.")
            else: # ƒê·∫£m b·∫£o timer ƒë√£ d·ª´ng n·∫øu kh√¥ng d√πng
                if self.runtime_timer.isActive(): self.runtime_timer.stop()

            # Reset tr·∫°ng th√°i ghi video
            self.video_writer = None; self.current_video_path = None; self.error_occurred_during_recording = False

            # V√¥ hi·ªáu h√≥a c√°c control c·∫•u h√¨nh
            self.disable_settings_while_processing(True)

        else: # --- Logic D·ª™NG ---
            self.log_activity("‚èπ ƒêang d·ª´ng x·ª≠ l√Ω...")
            # G·ª≠i t√≠n hi·ªáu d·ª´ng cho worker
            if self.processing_worker and self.processing_worker.isRunning():
                self.processing_worker.stop()
                # Kh√¥ng c·∫ßn wait l√¢u ·ªü ƒë√¢y, worker s·∫Ω t·ª± k·∫øt th√∫c khi self.running=False

            # D·ª´ng timer h·∫πn gi·ªù
            if self.runtime_timer.isActive():
                self.runtime_timer.stop()
                self.log_activity("‚è±Ô∏è ƒê√£ h·ªßy h·∫πn gi·ªù d·ª´ng.")

            # Ho√†n t·∫•t vi·ªác ghi video (n·∫øu ƒëang ghi)
            if self.video_writer is not None:
                vp = self.current_video_path # L∆∞u ƒë∆∞·ªùng d·∫´n tr∆∞·ªõc khi release
                try:
                    self.video_writer.release()
                    self.log_activity("‚ö™Ô∏è ƒê√£ d·ª´ng ghi video.")
                    # Ki·ªÉm tra v√† x·ª≠ l√Ω file video cu·ªëi c√πng
                    if vp and os.path.exists(vp):
                        if not self.error_occurred_during_recording: # Kh√¥ng c√≥ l·ªói -> x√≥a
                             try: os.remove(vp); self.log_activity(f"üóëÔ∏è ƒê√£ x√≥a video (kh√¥ng l·ªói): {os.path.basename(vp)}")
                             except Exception as e_rem: self.log_activity(f"‚ö†Ô∏è L·ªói khi x√≥a video '{os.path.basename(vp)}': {e_rem}")
                        else: # C√≥ l·ªói -> gi·ªØ l·∫°i
                             self.log_activity(f"üíæ ƒê√£ l∆∞u video (c√≥ l·ªói): {os.path.basename(vp)}")
                except Exception as e_vid_rel:
                    self.log_activity(f"‚ùå L·ªói khi gi·∫£i ph√≥ng VideoWriter: {e_vid_rel}")
                finally:
                    self.video_writer = None; self.current_video_path = None
                    self.error_occurred_during_recording = False

            # C·∫≠p nh·∫≠t UI tr·∫°ng th√°i d·ª´ng
            self.update_status_label(ComparisonStatus.UNKNOWN, {"status": "Stopped"})
            self.details_label.setText("Details: N/A") # Reset chi ti·∫øt

            # K√≠ch ho·∫°t l·∫°i c√°c control c·∫•u h√¨nh
            self.disable_settings_while_processing(False)
            self.log_activity("‚èπ Qu√° tr√¨nh x·ª≠ l√Ω ƒë√£ d·ª´ng.")

        # C·∫≠p nh·∫≠t text n√∫t Start/Stop
        self.update_toggle_button_text()


    @QtCore.pyqtSlot()
    def _mark_error_occurred(self):
        """ƒê√°nh d·∫•u l√† ƒë√£ c√≥ l·ªói x·∫£y ra trong phi√™n ghi video hi·ªán t·∫°i."""
        if self._record_on_error_enabled and not self.error_occurred_during_recording:
            self.log_activity("‚ùó Ph√°t hi·ªán l·ªói ƒë·∫ßu ti√™n. Video s·∫Ω ƒë∆∞·ª£c l∆∞u khi d·ª´ng.")
        self.error_occurred_during_recording = True


    def disable_settings_while_processing(self, disable):
        """B·∫≠t/t·∫Øt c√°c control c·∫•u h√¨nh d·ª±a tr√™n tr·∫°ng th√°i processing."""
        is_ssim = self.current_comparison_method == METHOD_SSIM
        is_yolo = self.current_comparison_method == METHOD_YOLO
        webcam_on = self.cap is not None and self.cap.isOpened()

        # 1. C√°c control chung
        self.comparisonMethodComboBox.setEnabled(not disable)
        self.SaveButton.setEnabled(not disable)
        self.cooldownSpinBox.setEnabled(not disable)
        self.runtimeSpinBox.setEnabled(not disable)
        self.ToggleRecordOnErrorButton.setEnabled(not disable)

        # 2. C√°c control theo ph∆∞∆°ng th·ª©c
        # B·∫≠t group t∆∞∆°ng ·ª©ng n·∫øu kh√¥ng disable V√Ä ƒë√∫ng ph∆∞∆°ng th·ª©c
        self.ssimGroup.setEnabled(not disable and is_ssim)
        self.yoloGroup.setEnabled(not disable and is_yolo)

        # 3. N√∫t ·∫£nh tham chi·∫øu (li√™n quan ƒë·∫øn SSIM)
        # C√≥ th·ªÉ lu√¥n b·∫≠t n√∫t t·∫£i, ch·ªâ b·∫≠t n√∫t ch·ª•p khi c√≥ webcam v√† l√† SSIM?
        can_use_ssim_refs = not disable # Hi·ªán t·∫°i cho ph√©p t∆∞∆°ng t√°c khi kh√¥ng processing
        for btn in [self.SettingButton_Norm, self.SettingButton_Shutdown, self.SettingButton_Fail]:
            btn.setEnabled(can_use_ssim_refs)
        for btn in [self.CaptureButton_Norm, self.CaptureButton_Shut, self.CaptureButton_Fail]:
            # B·∫≠t n·∫øu kh√¥ng x·ª≠ l√Ω, c√≥ webcam, V√Ä ƒëang ·ªü ch·∫ø ƒë·ªô SSIM (ho·∫∑c lu√¥n b·∫≠t n·∫øu mu·ªën)
            btn.setEnabled(can_use_ssim_refs and webcam_on and is_ssim)

        # 4. N√∫t ROI (ch·ªâ khi c√≥ webcam v√† kh√¥ng x·ª≠ l√Ω)
        self.SettingButton_ROI_Webcam.setEnabled(not disable and webcam_on)

        # 5. C·∫•u h√¨nh Serial
        self.serialGroup.setEnabled(not disable) # Lu√¥n b·∫≠t group khi kh√¥ng x·ª≠ l√Ω
        can_config_serial = not disable and not self.serial_enabled
        has_ports = hasattr(self, 'comPortComboBox') and self.comPortComboBox.count() > 0 and "Kh√¥ng t√¨m th·∫•y" not in self.comPortComboBox.itemText(0)
        self.comPortComboBox.setEnabled(can_config_serial and has_ports)
        self.baudRateComboBox.setEnabled(can_config_serial and has_ports)
        # N√∫t refresh ch·ªâ b·ªã v√¥ hi·ªáu h√≥a khi ƒëang k·∫øt n·ªëi
        self.refreshComButton.setEnabled(not self.serial_enabled)
        # N√∫t K·∫øt n·ªëi/Ng·∫Øt k·∫øt n·ªëi: B·∫≠t n·∫øu kh√¥ng x·ª≠ l√Ω v√† c√≥ c·ªïng
        self.ToggleSerialPortButton.setEnabled(not disable and has_ports)

        # 6. N√∫t Webcam
        self.ONCam.setEnabled(not disable and not webcam_on)
        self.OFFCam.setEnabled(not disable and webcam_on)


    @QtCore.pyqtSlot()
    def _runtime_timer_timeout(self):
        self.log_activity(f"‚è±Ô∏è ƒê√£ h·∫øt th·ªùi gian ch·∫°y ({self._current_runtime_minutes} ph√∫t).")
        QMessageBox.information(self,"H·∫øt Gi·ªù",f"ƒê√£ ch·∫°y ƒë·ªß {self._current_runtime_minutes} ph√∫t. ·ª®ng d·ª•ng s·∫Ω ƒë√≥ng.")
        # T·ª± ƒë·ªông d·ª´ng x·ª≠ l√Ω tr∆∞·ªõc khi ƒë√≥ng
        if self.processing:
             self.toggle_processing() # G·ªçi h√†m d·ª´ng chu·∫©n
        # G·ªçi h√†m ƒë√≥ng ·ª©ng d·ª•ng
        self.close_application()


    # --- comparison_ssim_strategy, compare_yolo_strategy, _check_yolo_rule gi·ªØ nguy√™n ---
    def compare_ssim_strategy(self, frame, ref_images, config):
        """So s√°nh SSIM v√† tr·∫£ v·ªÅ (ComparisonStatus, details)."""
        ssim_th = config.get('ssim_threshold', DEFAULT_SSIM_THRESHOLD)
        n_img = ref_images.get(REF_NORM)
        s_img = ref_images.get(REF_SHUTDOWN)
        f_img = ref_images.get(REF_FAIL)
        details = {}

        # B·∫Øt bu·ªôc ph·∫£i c√≥ ·∫£nh Norm
        if not isinstance(n_img, np.ndarray) or n_img.size == 0:
            return ComparisonStatus.ERROR, {"error": "·∫¢nh Norm kh√¥ng h·ª£p l·ªá"}

        score_n = ssim_opencv(frame, n_img)
        details["ssim_norm"] = score_n # Lu√¥n th√™m score Norm v√†o details
        if score_n is None: # L·ªói t√≠nh to√°n SSIM
            return ComparisonStatus.ERROR, {"error": "L·ªói t√≠nh SSIM vs Norm", **details}
        if score_n >= ssim_th: # Kh·ªõp Norm
            return ComparisonStatus.NORMAL, details

        # N·∫øu kh√¥ng kh·ªõp Norm, ki·ªÉm tra Shutdown (n·∫øu c√≥)
        if isinstance(s_img, np.ndarray) and s_img.size > 0:
            score_s = ssim_opencv(frame, s_img)
            details["ssim_shutdown"] = score_s # Th√™m score Shutdown
            if score_s is not None and score_s >= ssim_th:
                return ComparisonStatus.SHUTDOWN, details

        # N·∫øu kh√¥ng kh·ªõp Norm/Shutdown, ki·ªÉm tra Fail (n·∫øu c√≥)
        if isinstance(f_img, np.ndarray) and f_img.size > 0:
            score_f = ssim_opencv(frame, f_img)
            details["ssim_fail"] = score_f # Th√™m score Fail
            if score_f is not None and score_f >= ssim_th:
                return ComparisonStatus.FAIL, details

        # N·∫øu kh√¥ng kh·ªõp b·∫•t k·ª≥ ·∫£nh tham chi·∫øu n√†o
        return ComparisonStatus.UNKNOWN, details


    def compare_yolo_strategy(self, frame, yolo_rules, config):
        """So s√°nh YOLO d·ª±a tr√™n rules v√† tr·∫£ v·ªÅ (ComparisonStatus, details)."""
        if not YOLO_AVAILABLE or self.yolo_model is None:
            return ComparisonStatus.ERROR, {"error": "YOLO kh√¥ng s·∫µn s√†ng"}
        conf_threshold = config.get('yolo_confidence', DEFAULT_YOLO_CONFIDENCE)

        try:
            # === Th·ª±c hi·ªán d·ª± ƒëo√°n YOLO ===
            results = self.yolo_model.predict(frame, conf=conf_threshold, verbose=False, imgsz=max(32,frame.shape[0],frame.shape[1])) # K√≠ch th∆∞·ªõc ƒë·ªông?
            if not results or len(results) == 0:
                 return ComparisonStatus.ERROR, {"error": "YOLO predict kh√¥ng tr·∫£ v·ªÅ k·∫øt qu·∫£"}
            # ==============================

            detections = results[0] # L·∫•y k·∫øt qu·∫£ cho ·∫£nh ƒë·∫ßu ti√™n (v√† duy nh·∫•t)
            detected_objects = {}   # Dictionary {class_name: count}
            object_details_list = [] # List ch·ª©a th√¥ng tin chi ti·∫øt t·ª´ng box (t√πy ch·ªçn)
            obj_count = 0           # T·ªïng s·ªë ƒë·ªëi t∆∞·ª£ng ph√°t hi·ªán ƒë∆∞·ª£c

            # Tr√≠ch xu·∫•t th√¥ng tin t·ª´ k·∫øt qu·∫£ d·ª± ƒëo√°n
            if detections.boxes is not None and detections.names is not None:
                 obj_count = len(detections.boxes)
                 for i in range(obj_count): # L·∫∑p qua index thay v√¨ ƒë·ªëi t∆∞·ª£ng box tr·ª±c ti·∫øp
                     try:
                         box = detections.boxes[i] # L·∫•y ƒë·ªëi t∆∞·ª£ng box theo index
                         class_id = int(box.cls.item())
                         class_name = detections.names.get(class_id, f"ID_{class_id}")
                         confidence = float(box.conf.item())
                         # L·∫•y t·ªça ƒë·ªô h·ªôp gi·ªõi h·∫°n (v√≠ d·ª•: normalized xywh)
                         bbox_xywhn = box.xywhn.cpu().numpy()[0]

                         # ƒê·∫øm s·ªë l∆∞·ª£ng theo class name
                         detected_objects[class_name] = detected_objects.get(class_name, 0) + 1
                         # Th√™m chi ti·∫øt (t√πy ch·ªçn)
                         object_details_list.append({
                             "class": class_name, "conf": confidence,
                             "box_norm": [round(c, 4) for c in bbox_xywhn]
                         })
                     except Exception as box_err:
                          # Log l·ªói x·ª≠ l√Ω box c·ª• th·ªÉ m√† kh√¥ng d·ª´ng to√†n b·ªô
                          # Trong ·ª©ng d·ª•ng th·ª±c t·∫ø n√™n d√πng self.log_signal
                          print(f"Warning: L·ªói x·ª≠ l√Ω YOLO box: {box_err}")
                          continue # B·ªè qua box l·ªói n√†y

            # T·∫°o dictionary chi ti·∫øt k·∫øt qu·∫£
            details = {"detected": detected_objects, "count": obj_count}
            # if object_details_list: details["boxes"] = object_details_list # Th√™m chi ti·∫øt box n·∫øu c·∫ßn

            # === √Åp d·ª•ng quy t·∫Øc ===
            norm_rules = yolo_rules.get(REF_NORM, {})
            shut_rules = yolo_rules.get(REF_SHUTDOWN, {})
            fail_rules = yolo_rules.get(REF_FAIL, {})

            # ∆Øu ti√™n ki·ªÉm tra FAIL -> SHUTDOWN -> NORMAL
            is_fail, fail_reason = self._check_yolo_rule(detected_objects, fail_rules)
            if is_fail:
                details["reason"] = fail_reason
                return ComparisonStatus.FAIL, details

            is_shut, shut_reason = self._check_yolo_rule(detected_objects, shut_rules)
            if is_shut:
                details["reason"] = shut_reason
                return ComparisonStatus.SHUTDOWN, details

            is_norm, norm_reason = self._check_yolo_rule(detected_objects, norm_rules)
            if is_norm:
                details["reason"] = norm_reason
                return ComparisonStatus.NORMAL, details

            # N·∫øu kh√¥ng kh·ªõp quy t·∫Øc n√†o
            details["reason"] = "Kh√¥ng kh·ªõp quy t·∫Øc n√†o"
            return ComparisonStatus.UNKNOWN, details

        except Exception as e:
            # L·ªói trong qu√° tr√¨nh d·ª± ƒëo√°n ho·∫∑c x·ª≠ l√Ω k·∫øt qu·∫£ YOLO
            err_msg = f"YOLO Exception: {type(e).__name__}: {e}"
            print(f"üí• {err_msg}") # In ra console ƒë·ªÉ debug nhanh
            traceback.print_exc()    # In traceback ƒë·∫ßy ƒë·ªß
            # C√≥ th·ªÉ d√πng self.log_signal n·∫øu mu·ªën ghi v√†o log ch√≠nh th·ª©c
            return ComparisonStatus.ERROR, {"error": err_msg}


    def _check_yolo_rule(self, detected_objects, rules):
        """Ki·ªÉm tra xem c√°c ƒë·ªëi t∆∞·ª£ng ph√°t hi·ªán c√≥ kh·ªõp v·ªõi b·ªô quy t·∫Øc kh√¥ng.
        Tr·∫£ v·ªÅ: (bool: True n·∫øu kh·ªõp, False n·∫øu kh√¥ng, str: L√Ω do kh·ªõp/kh√¥ng kh·ªõp)
        """
        if not rules: return False, "Kh√¥ng c√≥ quy t·∫Øc ƒë·ªÉ ki·ªÉm tra"

        reasons = [] # L∆∞u l·∫°i l√Ω do vi ph·∫°m ho·∫∑c kh·ªõp
        match_overall = True # Gi·∫£ ƒë·ªãnh l√† kh·ªõp ban ƒë·∫ßu

        # --- Ki·ªÉm tra c√°c lo·∫°i quy t·∫Øc ---

        # 1. Quy t·∫Øc "any_of": C·∫ßn √≠t nh·∫•t m·ªôt ƒë·ªëi t∆∞·ª£ng trong danh s√°ch
        any_of_list = rules.get("any_of")
        if any_of_list and isinstance(any_of_list, list):
            found_any = False
            for obj_name in any_of_list:
                if detected_objects.get(obj_name, 0) > 0:
                    found_any = True; break
            if not found_any:
                match_overall = False
                reasons.append(f"Thi·∫øu m·ªôt trong c√°c ƒë·ªëi t∆∞·ª£ng b·∫Øt bu·ªôc 'any_of': {', '.join(any_of_list)}")
            else: # Kh·ªõp quy t·∫Øc 'any_of'
                # N·∫øu 'any_of' l√† quy t·∫Øc DUY NH·∫§T, tr·∫£ v·ªÅ kh·ªõp ngay
                if len(rules) == 1: return True, f"T√¨m th·∫•y m·ªôt trong 'any_of': {', '.join(any_of_list)}"
                reasons.append(f"Kh·ªõp 'any_of': t√¨m th·∫•y m·ªôt trong {', '.join(any_of_list)}") # Ghi nh·∫≠n kh·ªõp
            # N·∫øu 'any_of' kh√¥ng kh·ªõp, tr·∫£ v·ªÅ ngay (v√¨ ƒë√¢y l√† ƒëi·ªÅu ki·ªán HO·∫∂C)
            if not match_overall: return False, "; ".join(reasons)

        # 2. Quy t·∫Øc "required_objects" v√† "min_counts": C√°c ƒë·ªëi t∆∞·ª£ng b·∫Øt bu·ªôc ph·∫£i c√≥ ƒë·ªß s·ªë l∆∞·ª£ng
        required_list = rules.get("required_objects", [])
        min_counts_dict = rules.get("min_counts", {})
        if required_list: # Ch·ªâ ki·ªÉm tra n·∫øu c√≥ danh s√°ch y√™u c·∫ßu
             rule_violated = False
             temp_reasons = []
             for req_obj in required_list:
                 req_count = min_counts_dict.get(req_obj, 1) # M·∫∑c ƒë·ªãnh c·∫ßn √≠t nh·∫•t 1
                 actual_count = detected_objects.get(req_obj, 0)
                 if actual_count < req_count:
                     rule_violated = True
                     temp_reasons.append(f"Thi·∫øu '{req_obj}' (c·∫ßn {req_count}, c√≥ {actual_count})")
             if rule_violated:
                 match_overall = False
                 reasons.extend(temp_reasons)
             else: reasons.append("Kh·ªõp 'required_objects'") # Ghi nh·∫≠n kh·ªõp

        # 3. Quy t·∫Øc "forbidden_objects": C√°c ƒë·ªëi t∆∞·ª£ng kh√¥ng ƒë∆∞·ª£c ph√©p xu·∫•t hi·ªán
        forbidden_list = rules.get("forbidden_objects", [])
        if forbidden_list:
            rule_violated = False
            temp_reasons = []
            for fob_obj in forbidden_list:
                if detected_objects.get(fob_obj, 0) > 0:
                    rule_violated = True
                    temp_reasons.append(f"Ph√°t hi·ªán ƒë·ªëi t∆∞·ª£ng c·∫•m '{fob_obj}'")
            if rule_violated:
                match_overall = False
                reasons.extend(temp_reasons)
            else: reasons.append("Kh·ªõp 'forbidden_objects'")

        # 4. Quy t·∫Øc "max_total_objects": Gi·ªõi h·∫°n t·ªïng s·ªë ƒë·ªëi t∆∞·ª£ng t·ªëi ƒëa
        max_total = rules.get("max_total_objects")
        if max_total is not None: # Ch·ªâ ki·ªÉm tra n·∫øu c√≥ gi√° tr·ªã
            current_total = sum(detected_objects.values())
            if current_total > max_total:
                match_overall = False
                reasons.append(f"Qu√° nhi·ªÅu ƒë·ªëi t∆∞·ª£ng (t·ªëi ƒëa {max_total}, c√≥ {current_total})")
            else: reasons.append("Kh·ªõp 'max_total_objects'")

        # 5. Quy t·∫Øc "exact_total_objects": Y√™u c·∫ßu ch√≠nh x√°c t·ªïng s·ªë ƒë·ªëi t∆∞·ª£ng
        exact_total = rules.get("exact_total_objects")
        if exact_total is not None:
            current_total = sum(detected_objects.values())
            if current_total != exact_total:
                match_overall = False
                reasons.append(f"Sai t·ªïng s·ªë ƒë·ªëi t∆∞·ª£ng (c·∫ßn {exact_total}, c√≥ {current_total})")
            else: reasons.append("Kh·ªõp 'exact_total_objects'")

        # K·∫øt lu·∫≠n cu·ªëi c√πng
        if match_overall:
            if not reasons: return True, "Kh·ªõp (kh√¥ng c√≥ quy t·∫Øc c·ª• th·ªÉ)" # Tr∆∞·ªùng h·ª£p rules={}
            return True, "; ".join(filter(lambda r: not r.startswith("Kh·ªõp"), reasons)) or "T·∫•t c·∫£ quy t·∫Øc kh·ªõp" # ∆Øu ti√™n l√Ω do vi ph·∫°m n·∫øu c√≥ l·∫´n l·ªôn
        else:
            return False, "; ".join(filter(lambda r: not r.startswith("Kh·ªõp"), reasons)) # Ch·ªâ tr·∫£ v·ªÅ l√Ω do vi ph·∫°m


    # --- save_error_image_from_thread, close_application, closeEvent gi·ªØ nguy√™n ---
    @QtCore.pyqtSlot(np.ndarray, str)
    def save_error_image_from_thread(self, frame_copy, file_path):
        try:
            save_dir = os.path.dirname(file_path)
            if not os.path.exists(save_dir): os.makedirs(save_dir, exist_ok=True)
            # S·ª≠ d·ª•ng imencode ƒë·ªÉ x·ª≠ l√Ω ƒë·ªãnh d·∫°ng PNG v√† n√©n
            success, buf = cv2.imencode('.png', frame_copy, [cv2.IMWRITE_PNG_COMPRESSION, 3]) # M·ª©c n√©n v·ª´a ph·∫£i
            if not success or buf is None:
                raise ValueError("cv2.imencode th·∫•t b·∫°i.")
            # Ghi buffer v√†o file
            with open(file_path, "wb") as f:
                f.write(buf.tobytes())
            self.log_activity(f"üíæ L∆∞u ·∫£nh l·ªói: {os.path.basename(file_path)}")
        except Exception as e:
            self.log_activity(f"‚ùå L·ªói khi l∆∞u ·∫£nh l·ªói '{os.path.basename(file_path)}': {e}")
            self.log_activity(traceback.format_exc()) # Log traceback v√¨ ƒë√¢y l√† lu·ªìng ch√≠nh

    def close_application(self):
        """ƒê√≥ng ·ª©ng d·ª•ng m·ªôt c√°ch an to√†n."""
        self.log_activity("üö™ ƒêang y√™u c·∫ßu ƒë√≥ng ·ª©ng d·ª•ng...")
        self.close() # K√≠ch ho·∫°t s·ª± ki·ªán closeEvent

    def closeEvent(self, event):
        """X·ª≠ l√Ω s·ª± ki·ªán ƒë√≥ng c·ª≠a s·ªï, d·ªçn d·∫πp t√†i nguy√™n."""
        self.log_activity("üö™ B·∫Øt ƒë·∫ßu qu√° tr√¨nh d·ªçn d·∫πp tr∆∞·ªõc khi ƒë√≥ng...")

        # 1. D·ª´ng c√°c Timers
        if self.runtime_timer.isActive(): self.runtime_timer.stop()
        if self.frame_timer.isActive(): self.frame_timer.stop()

        # 2. D·ª´ng Worker thread
        worker_stopped_cleanly = True
        if self.processing_worker and self.processing_worker.isRunning():
            self.log_activity("‚öôÔ∏è D·ª´ng lu·ªìng x·ª≠ l√Ω...")
            self.processing_worker.stop()
            # Ch·ªù worker d·ª´ng m·ªôt ch√∫t
            if not self.processing_worker.wait(2000): # Ch·ªù t·ªëi ƒëa 2 gi√¢y
                self.log_activity("‚ö†Ô∏è Lu·ªìng x·ª≠ l√Ω kh√¥ng d·ª´ng k·ªãp th·ªùi!")
                worker_stopped_cleanly = False
            # else: self.log_activity("‚úÖ Lu·ªìng x·ª≠ l√Ω ƒë√£ d·ª´ng.")
        self.processing = False # ƒê·∫∑t c·ªù processing v·ªÅ False

        # 3. Gi·∫£i ph√≥ng Webcam
        if self.cap and self.cap.isOpened():
            try: self.cap.release()
            except Exception: pass # B·ªè qua l·ªói release
            finally: self.cap = None; self.log_activity("üö´ Webcam ƒë√£ gi·∫£i ph√≥ng.")

        # 4. Ho√†n t·∫•t ghi Video
        if self.video_writer is not None:
            vp = self.current_video_path
            try:
                self.video_writer.release()
                self.log_activity("‚ö™Ô∏è Video writer ƒë√£ gi·∫£i ph√≥ng.")
                if vp and os.path.exists(vp):
                    if not self.error_occurred_during_recording:
                         try: os.remove(vp); self.log_activity(f"üóëÔ∏è ƒê√£ x√≥a video cu·ªëi (kh√¥ng l·ªói).")
                         except Exception as e: self.log_activity(f"‚ö†Ô∏è L·ªói x√≥a video cu·ªëi: {e}")
                    else:
                         self.log_activity(f"üíæ ƒê√£ l∆∞u video cu·ªëi (c√≥ l·ªói).")
            except Exception as e: self.log_activity(f"‚ùå L·ªói gi·∫£i ph√≥ng VideoWriter: {e}")
            finally: self.video_writer, self.current_video_path = None, None

        # 5. ƒê√≥ng c·ªïng Serial
        if self.serial_port and self.serial_port.is_open:
            port_name = self.serial_port.name or "N/A"
            try: self.serial_port.close(); self.log_activity(f"üîå ƒê√£ ƒë√≥ng c·ªïng COM {port_name}.")
            except Exception as e: self.log_activity(f"‚ö†Ô∏è L·ªói ƒë√≥ng COM {port_name}: {e}")
            finally: self.serial_port = None; self.serial_enabled = False

        # 6. D·ªçn s·∫°ch Queue
        # (V√≤ng l·∫∑p while ƒë√£ s·ª≠a ·ªü c√°c phi√™n b·∫£n tr∆∞·ªõc)
        q_size = self.frame_queue.qsize()
        if q_size > 0: self.log_activity(f"‚ÑπÔ∏è D·ªçn {q_size} frame c√≤n l·∫°i trong queue...")
        while not self.frame_queue.empty():
            try: self.frame_queue.get_nowait()
            except Empty: break

        # 7. Gi·∫£i ph√≥ng Model YOLO
        if self.yolo_model is not None:
             self.log_activity("üß† Gi·∫£i ph√≥ng model YOLO...")
             del self.yolo_model; self.yolo_model = None
             # Optional: GPU cleanup if using PyTorch explicitly
             # try:
             #     import torch
             #     if torch.cuda.is_available(): torch.cuda.empty_cache()
             # except ImportError: pass
             # except Exception as e_cuda: print(f"Note: L·ªói cleanup CUDA: {e_cuda}")

        # 8. L∆∞u c·∫•u h√¨nh l·∫ßn cu·ªëi
        self.log_activity("üíæ L∆∞u c·∫•u h√¨nh cu·ªëi c√πng...")
        self.save_config()

        self.log_activity("üö™ D·ªçn d·∫πp ho√†n t·∫•t. T·∫°m bi·ªát!")
        # Ghi d√≤ng log cu·ªëi v√†o file
        if self.log_file_path:
             try:
                 timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
                 with open(self.log_file_path,"a",encoding="utf-8") as lf:
                      lf.write(f"---\n{timestamp} - ·ª®ng d·ª•ng ƒë√£ ƒë√≥ng\n---\n")
             except Exception as e: print(f"L·ªói ghi log cu·ªëi: {e}")

        event.accept() # Ch·∫•p nh·∫≠n s·ª± ki·ªán ƒë√≥ng

# --- Main Execution ---
if __name__ == "__main__":
    # C√†i ƒë·∫∑t cho m√†n h√¨nh HiDPI (n·∫øu c√≥)
    if hasattr(QtCore.Qt, 'AA_EnableHighDpiScaling'):
         QtWidgets.QApplication.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling, True)
    if hasattr(QtCore.Qt, 'AA_UseHighDpiPixmaps'):
         QtWidgets.QApplication.setAttribute(QtCore.Qt.AA_UseHighDpiPixmaps, True)

    # Kh·ªüi t·∫°o ·ª©ng d·ª•ng Qt
    app = QtWidgets.QApplication(sys.argv)
    # T·∫°o v√† hi·ªÉn th·ªã c·ª≠a s·ªï ch√≠nh
    window = ImageCheckerApp()
    window.show()
    # B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p s·ª± ki·ªán c·ªßa ·ª©ng d·ª•ng
    sys.exit(app.exec_())
